{
  "master": {
    "tasks": [
      {
        "id": "1",
        "title": "Initialize Cloudflare Workers project with TypeScript and Wrangler configuration",
        "description": "Set up the base Cloudflare Workers project structure using create-cloudflare CLI, configure wrangler.toml for D1, R2, KV bindings, and establish TypeScript configuration with strict mode.",
        "details": "Run `npm create cloudflare@latest` to scaffold the Workers project. Configure wrangler.toml with:\n- D1 binding for database (name: journalizer_db)\n- R2 binding for media storage (name: journalizer_media)\n- KV binding for sessions/cache (name: journalizer_kv)\n- Environment variables placeholders for GOOGLE_CLIENT_ID, GOOGLE_CLIENT_SECRET, TWILIO_*, ANTHROPIC_API_KEY, DEEPGRAM_API_KEY\n\nSet up tsconfig.json with strict mode, ESNext target, and proper module resolution. Create .env.example with all required keys. Initialize package.json with dependencies: @cloudflare/workers-types, drizzle-orm, hono (for routing), zod (for validation).\n\nProject structure should match PRD section 2.3 with src/, glass/, tests/, dist/, glass-views/, annotations/ directories.",
        "testStrategy": "Verify wrangler.toml syntax with `wrangler deploy --dry-run`. Confirm TypeScript compiles with `tsc --noEmit`. Validate all directories exist and package.json has correct dependencies. Test that `wrangler dev` starts successfully.",
        "priority": "high",
        "dependencies": [
          "23"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Scaffold Cloudflare Workers project using create-cloudflare CLI",
            "description": "Run the create-cloudflare CLI tool to generate the initial Cloudflare Workers project structure with TypeScript support.",
            "dependencies": [],
            "details": "Execute `npm create cloudflare@latest` in the /Users/supercleanse/Development/journalizer directory. Select options for: TypeScript template, Workers project type, and initialize git repository. This will generate the base project structure including package.json, tsconfig.json, wrangler.toml, and src/index.ts starter files. Accept default project name 'journalizer' or specify it during the CLI prompts.",
            "status": "pending",
            "testStrategy": "Verify that the scaffolding completed successfully by checking that package.json, wrangler.toml, tsconfig.json, and src/index.ts files exist. Run `npm install` to ensure dependencies install without errors.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Configure wrangler.toml with D1, R2, and KV bindings",
            "description": "Set up all required Cloudflare service bindings in wrangler.toml for database, media storage, and key-value cache.",
            "dependencies": [
              1
            ],
            "details": "Edit wrangler.toml to add binding configurations: (1) D1 database binding with name 'journalizer_db' using [[d1_databases]] block, (2) R2 bucket binding with name 'journalizer_media' using [[r2_buckets]] block, (3) KV namespace binding with name 'journalizer_kv' using [[kv_namespaces]] block. Add [vars] section with placeholder environment variables: GOOGLE_CLIENT_ID, GOOGLE_CLIENT_SECRET, TWILIO_ACCOUNT_SID, TWILIO_AUTH_TOKEN, TWILIO_PHONE_NUMBER, ANTHROPIC_API_KEY, DEEPGRAM_API_KEY. Set compatibility_date to current date and node_compat = true.",
            "status": "pending",
            "testStrategy": "Run `wrangler deploy --dry-run` to validate wrangler.toml syntax without deploying. Verify no configuration errors are reported. Check that all bindings are recognized by the wrangler CLI.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Configure TypeScript with strict mode and proper module resolution",
            "description": "Update tsconfig.json with strict type checking, ESNext target, and module resolution settings appropriate for Cloudflare Workers.",
            "dependencies": [
              1
            ],
            "details": "Modify tsconfig.json to set: \"strict\": true, \"target\": \"ESNext\", \"module\": \"ESNext\", \"moduleResolution\": \"bundler\", \"lib\": [\"ESNext\"], \"types\": [\"@cloudflare/workers-types\"], \"skipLibCheck\": true, \"resolveJsonModule\": true, \"allowSyntheticDefaultImports\": true, \"esModuleInterop\": true, \"isolatedModules\": true, \"noEmit\": true. Set \"include\": [\"src/**/*\"] and \"exclude\": [\"node_modules\", \"dist\"].",
            "status": "pending",
            "testStrategy": "Run `tsc --noEmit` to verify TypeScript configuration compiles without errors. Create a simple test file in src/ with strict type checking scenarios to ensure strict mode is enforced.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Install required dependencies in package.json",
            "description": "Add all necessary npm packages for the Workers project including framework, ORM, validation, and Cloudflare types.",
            "dependencies": [
              1
            ],
            "details": "Install production dependencies: `npm install hono drizzle-orm zod`. Install development dependencies: `npm install -D @cloudflare/workers-types typescript wrangler`. Verify package.json includes these packages with appropriate version ranges (use latest stable versions). Ensure scripts section includes: \"dev\": \"wrangler dev\", \"deploy\": \"wrangler deploy\", \"typecheck\": \"tsc --noEmit\", \"lint\": \"eslint src\".",
            "status": "pending",
            "testStrategy": "Run `npm install` and verify all packages install successfully without peer dependency warnings. Run `npm run typecheck` to ensure @cloudflare/workers-types are properly recognized. Verify `npm run dev` can start the development server.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Create project directory structure and environment template",
            "description": "Set up the complete directory hierarchy as specified in PRD section 2.3 and create .env.example with all required API key placeholders.",
            "dependencies": [
              1
            ],
            "details": "Create directories: src/, glass/, tests/, dist/, glass-views/, annotations/. Within src/, create subdirectories: db/, routes/, services/, utils/, types/. Create .env.example file with placeholder entries for all environment variables: GOOGLE_CLIENT_ID=your_google_client_id_here, GOOGLE_CLIENT_SECRET=your_google_client_secret_here, TWILIO_ACCOUNT_SID=your_twilio_account_sid_here, TWILIO_AUTH_TOKEN=your_twilio_auth_token_here, TWILIO_PHONE_NUMBER=your_twilio_phone_number_here, ANTHROPIC_API_KEY=your_anthropic_api_key_here, DEEPGRAM_API_KEY=your_deepgram_api_key_here. Add .env to .gitignore if not already present.",
            "status": "pending",
            "testStrategy": "Verify all directories exist with `ls -R` command. Confirm .env.example contains all required environment variable placeholders. Ensure .env is listed in .gitignore to prevent accidental commits of secrets. Run `wrangler dev` to verify the project structure is valid.",
            "parentId": "undefined"
          }
        ],
        "complexity": 3,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Break down the project initialization into: (1) scaffold Cloudflare Workers project with create-cloudflare CLI, (2) configure wrangler.toml with D1/R2/KV bindings, (3) set up TypeScript with strict mode and proper module resolution, (4) create package.json with required dependencies (hono, drizzle-orm, zod, @cloudflare/workers-types), (5) create directory structure (src/, glass/, tests/, dist/, glass-views/, annotations/) and .env.example with all API key placeholders"
      },
      {
        "id": "2",
        "title": "Design and implement D1 database schema with migration system",
        "description": "Create the complete D1 SQLite schema as specified in PRD section 6, including users, entries, media, reminders, processing_log, and print_subscriptions tables with proper indexes and foreign key constraints.",
        "details": "Create `src/db/schema.sql` with all six tables (users, entries, media, reminders, processing_log, print_subscriptions) exactly as defined in PRD section 6. Use TEXT for primary keys (UUIDs), proper foreign key constraints with ON DELETE CASCADE, and all specified indexes.\n\nSet up Drizzle ORM schema definitions in `src/db/schema.ts` mirroring the SQL schema. Configure Drizzle to use SQLite dialect. Create migration system in `src/db/migrations/` with timestamped migration files.\n\nImplement `src/db/queries.ts` with typed query helpers for common operations: getUserById, createUser, createEntry, listEntries (with pagination), etc.\n\nCreate corresponding Glass specs:\n- `glass/db/schema.glass` - Intent: data persistence layer; Contract: guarantees ACID properties, foreign key integrity\n- `glass/db/queries.glass` - Intent: type-safe database access; Contract: guarantees SQL injection protection, proper error handling",
        "testStrategy": "Run `wrangler d1 create journalizer_db` and apply migrations with `wrangler d1 migrations apply`. Verify schema with `wrangler d1 execute --command=\".schema\"`. Write unit tests for Drizzle query helpers to ensure correct SQL generation and type safety. Test foreign key cascade behavior.",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create SQL schema file with users table and indexes",
            "description": "Create src/db/schema.sql and implement the users table with all fields as specified in PRD section 6, including proper primary key, indexes, and constraints.",
            "dependencies": [],
            "details": "Create src/db/schema.sql file. Define users table with columns: id (TEXT PRIMARY KEY), email (TEXT UNIQUE NOT NULL), name (TEXT), picture_url (TEXT), phone_number (TEXT UNIQUE), phone_verified (INTEGER DEFAULT 0), timezone (TEXT DEFAULT 'UTC'), created_at (TEXT NOT NULL), updated_at (TEXT NOT NULL). Add indexes: CREATE INDEX idx_users_email ON users(email); CREATE INDEX idx_users_phone ON users(phone_number);. Enable foreign key constraints with PRAGMA foreign_keys = ON;",
            "status": "pending",
            "testStrategy": "Apply schema to local D1 instance using wrangler d1 execute, verify table structure with .schema command, test inserting sample user data with UUID, verify unique constraints on email and phone_number",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Add entries table with foreign keys and indexes",
            "description": "Add the entries table to schema.sql with proper foreign key constraints to users table, ON DELETE CASCADE behavior, and performance indexes.",
            "dependencies": [
              1
            ],
            "details": "Add entries table to schema.sql with columns: id (TEXT PRIMARY KEY), user_id (TEXT NOT NULL REFERENCES users(id) ON DELETE CASCADE), content (TEXT), transcribed_content (TEXT), entry_type (TEXT CHECK(entry_type IN ('sms', 'mms', 'email', 'web', 'voice'))), source_phone (TEXT), source_email (TEXT), media_count (INTEGER DEFAULT 0), created_at (TEXT NOT NULL), updated_at (TEXT NOT NULL). Add indexes: CREATE INDEX idx_entries_user_id ON entries(user_id); CREATE INDEX idx_entries_created_at ON entries(created_at); CREATE INDEX idx_entries_user_created ON entries(user_id, created_at DESC);",
            "status": "pending",
            "testStrategy": "Test foreign key constraint by attempting to insert entry with non-existent user_id (should fail), verify ON DELETE CASCADE by deleting user and confirming entries are deleted, test CHECK constraint with invalid entry_type values",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Add media table with R2 key references",
            "description": "Implement the media table in schema.sql for tracking uploaded media files stored in R2, with foreign keys to entries table and proper indexes.",
            "dependencies": [
              2
            ],
            "details": "Add media table to schema.sql with columns: id (TEXT PRIMARY KEY), entry_id (TEXT NOT NULL REFERENCES entries(id) ON DELETE CASCADE), r2_key (TEXT NOT NULL), media_type (TEXT CHECK(media_type IN ('image', 'audio', 'video', 'document'))), mime_type (TEXT NOT NULL), file_size (INTEGER), width (INTEGER), height (INTEGER), duration (REAL), thumbnail_r2_key (TEXT), created_at (TEXT NOT NULL). Add indexes: CREATE INDEX idx_media_entry_id ON media(entry_id); CREATE INDEX idx_media_r2_key ON media(r2_key);",
            "status": "pending",
            "testStrategy": "Test foreign key cascade from entries to media by deleting entry and verifying media records are deleted, verify CHECK constraint on media_type, test inserting media with all supported types and nullable fields (width, height, duration, thumbnail_r2_key)",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Add reminders and processing_log tables",
            "description": "Add reminders table for user notification preferences and processing_log table for tracking asynchronous AI/transcription operations.",
            "dependencies": [
              1
            ],
            "details": "Add reminders table with columns: id (TEXT PRIMARY KEY), user_id (TEXT NOT NULL REFERENCES users(id) ON DELETE CASCADE), reminder_type (TEXT CHECK(reminder_type IN ('daily', 'weekly', 'monthly', 'smart'))), time_of_day (TEXT), day_of_week (INTEGER CHECK(day_of_week BETWEEN 0 AND 6)), day_of_month (INTEGER CHECK(day_of_month BETWEEN 1 AND 28)), smart_threshold (INTEGER CHECK(smart_threshold BETWEEN 1 AND 14)), is_active (INTEGER DEFAULT 1), created_at (TEXT NOT NULL). Add processing_log table with columns: id (TEXT PRIMARY KEY), entry_id (TEXT REFERENCES entries(id) ON DELETE SET NULL), operation_type (TEXT CHECK(operation_type IN ('transcription', 'ai_enhancement', 'summarization'))), status (TEXT CHECK(status IN ('pending', 'processing', 'completed', 'failed'))), error_message (TEXT), started_at (TEXT), completed_at (TEXT). Add indexes: CREATE INDEX idx_reminders_user_id ON reminders(user_id); CREATE INDEX idx_processing_status ON processing_log(status, started_at);",
            "status": "pending",
            "testStrategy": "Test all CHECK constraints with valid and invalid values, verify reminders CASCADE delete with user, test processing_log SET NULL behavior when entry is deleted, verify index performance on processing_log status queries",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Add print_subscriptions table",
            "description": "Create the print_subscriptions table for managing monthly photo book delivery subscriptions with address and status tracking.",
            "dependencies": [
              1
            ],
            "details": "Add print_subscriptions table to schema.sql with columns: id (TEXT PRIMARY KEY), user_id (TEXT NOT NULL REFERENCES users(id) ON DELETE CASCADE), subscription_status (TEXT CHECK(subscription_status IN ('active', 'paused', 'cancelled'))), shipping_name (TEXT NOT NULL), shipping_address_line1 (TEXT NOT NULL), shipping_address_line2 (TEXT), shipping_city (TEXT NOT NULL), shipping_state (TEXT NOT NULL), shipping_postal_code (TEXT NOT NULL), shipping_country (TEXT NOT NULL DEFAULT 'US'), last_print_date (TEXT), next_print_date (TEXT), created_at (TEXT NOT NULL), updated_at (TEXT NOT NULL). Add index: CREATE INDEX idx_print_user_id ON print_subscriptions(user_id);",
            "status": "pending",
            "testStrategy": "Test foreign key CASCADE with user deletion, verify CHECK constraint on subscription_status values, test nullable fields (address_line2, last_print_date, next_print_date), verify DEFAULT value for shipping_country",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Set up Drizzle ORM schema definitions in TypeScript",
            "description": "Create src/db/schema.ts with Drizzle ORM table definitions that mirror the SQL schema, using SQLite dialect and proper TypeScript types.",
            "dependencies": [
              5
            ],
            "details": "Install drizzle-orm and configure SQLite dialect. Create src/db/schema.ts with Drizzle table definitions for all six tables using sqliteTable(). Map SQL types: TEXT->text(), INTEGER->integer(), REAL->real(). Define foreign key relationships using references(). Export table schemas and infer TypeScript types using typeof. Create src/db/index.ts to initialize Drizzle client with D1 binding. Set up drizzle.config.ts for migration configuration pointing to src/db/migrations/ directory with timestamped migration files.",
            "status": "pending",
            "testStrategy": "Run npm run typecheck to verify TypeScript types are correctly inferred, test Drizzle client initialization with mock D1 binding, verify schema matches SQL by generating migration and comparing to schema.sql",
            "parentId": "undefined"
          },
          {
            "id": 7,
            "title": "Implement typed query helpers for database operations",
            "description": "Create src/db/queries.ts with type-safe query helper functions for common database operations including pagination, using Drizzle ORM query builder.",
            "dependencies": [
              6
            ],
            "details": "Implement query helpers in src/db/queries.ts: getUserById(db, id) returns User | undefined, createUser(db, data: NewUser) returns User, updateUser(db, id, data) returns User, getUserByEmail(db, email), getUserByPhone(db, phone), createEntry(db, data: NewEntry) returns Entry, listEntries(db, userId, options: { limit: number, offset: number, orderBy: 'asc'|'desc' }) returns { entries: Entry[], total: number }, getEntryById(db, id) with media eager loading, createReminder(db, data), listReminders(db, userId), createMedia(db, data), logProcessing(db, data). Use Drizzle query builder with proper typing, parameterized queries for SQL injection protection, and error handling with try-catch.",
            "status": "pending",
            "testStrategy": "Write unit tests for each query helper using in-memory SQLite database, verify pagination logic with edge cases (offset beyond results, limit=0), test SQL injection protection by passing malicious inputs, verify foreign key errors are properly caught and returned, test eager loading for entries with media",
            "parentId": "undefined"
          },
          {
            "id": 8,
            "title": "Create Glass specification files for database layer",
            "description": "Create Glass framework specification files glass/db/schema.glass and glass/db/queries.glass documenting the Intent and Contract for the database persistence layer.",
            "dependencies": [
              7
            ],
            "details": "Create glass/db/schema.glass with Intent section describing the data persistence layer purpose and Contract section guaranteeing ACID properties, foreign key integrity enforcement, CASCADE deletion behavior, and data validation via CHECK constraints. Create glass/db/queries.glass with Intent section describing type-safe database access abstraction and Contract section guaranteeing SQL injection protection via parameterized queries, proper error handling with typed return values, pagination correctness, and transaction support. Follow GLASS.md format with clear Intent and Contract sections.",
            "status": "pending",
            "testStrategy": "Validate Glass spec files follow GLASS.md format requirements, verify Contract guarantees match implementation in queries.ts, ensure Intent clearly describes the 'why' for each component, run through Glass framework validation if tooling exists",
            "parentId": "undefined"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 8,
        "expansionPrompt": "Break down the database schema implementation into: (1) create raw SQL schema file with users table and indexes, (2) add entries table with proper foreign keys and indexes, (3) add media table with R2 key references, (4) add reminders and processing_log tables, (5) add print_subscriptions table, (6) set up Drizzle ORM schema definitions in TypeScript matching SQL schema, (7) implement typed query helpers (getUserById, createUser, createEntry, listEntries with pagination), (8) create Glass spec files for db/schema.glass and db/queries.glass with proper Intent and Contract sections"
      },
      {
        "id": "3",
        "title": "Implement Google OAuth 2.0 authentication flow with session management",
        "description": "Build complete OAuth authentication using Google OAuth 2.0, including login initiation, callback handling, JWT session management with HttpOnly cookies, and CSRF protection.",
        "details": "Implement four auth endpoints in `src/routes/auth.ts`:\n\n1. GET /auth/google - Redirect to Google consent screen with state parameter for CSRF protection, scopes: email, profile\n2. GET /auth/callback - Exchange authorization code for tokens using Google token endpoint, extract user info from ID token (sub, email, name, picture), create/update user in D1, issue session JWT\n3. POST /auth/logout - Clear session cookie and KV session entry\n4. GET /auth/me - Return current user info from JWT\n\nStore JWT signing key as Worker Secret. Sessions stored in KV with 1-hour TTL, refresh tokens in KV with 7-day TTL. JWT payload: { userId, email, iat, exp }. Use HttpOnly, Secure, SameSite=Lax cookies.\n\nCreate middleware in `src/lib/auth.ts` for JWT verification and user context injection.\n\nGlass specs:\n- `glass/auth/oauth.glass` - Intent: user identity verification; Contract: guarantees CSRF protection, secure token handling, no credential exposure\n- `glass/auth/session.glass` - Intent: stateless session management; Contract: guarantees JWT integrity, automatic expiration, HttpOnly cookie security",
        "testStrategy": "Mock Google OAuth endpoints and test full flow. Verify state parameter prevents CSRF. Test JWT signing/verification. Confirm cookies have HttpOnly and Secure flags. Test session expiration and refresh. Validate that invalid JWTs are rejected.",
        "priority": "high",
        "dependencies": [
          "2"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement GET /auth/google endpoint with Google OAuth consent redirect",
            "description": "Create the initial OAuth flow endpoint that redirects users to Google's consent screen with proper CSRF state parameter and OAuth scopes (email, profile).",
            "dependencies": [],
            "details": "In `src/routes/auth.ts`, implement GET /auth/google endpoint that: (1) generates a cryptographically secure random state parameter for CSRF protection, (2) stores state in KV with 5-minute TTL, (3) constructs Google OAuth URL with client_id, redirect_uri, response_type=code, scope=email+profile, state parameter, (4) redirects user to Google consent screen. Client ID and redirect URI should be from Worker environment variables.",
            "status": "pending",
            "testStrategy": "Test that endpoint generates unique state parameters for each request. Verify state is stored in KV with correct TTL. Test that redirect URL contains all required OAuth parameters. Verify state parameter is cryptographically random (not predictable).",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement GET /auth/callback endpoint with authorization code exchange",
            "description": "Build the OAuth callback handler that receives the authorization code from Google, validates the state parameter, and exchanges the code for access and ID tokens.",
            "dependencies": [
              1
            ],
            "details": "In `src/routes/auth.ts`, implement GET /auth/callback endpoint that: (1) extracts code and state query parameters, (2) validates state against KV store and deletes it (one-time use), (3) exchanges authorization code for tokens by POSTing to Google's token endpoint (https://oauth2.googleapis.com/token) with code, client_id, client_secret, redirect_uri, grant_type=authorization_code, (4) receives access_token, id_token, and refresh_token in response. Handle errors for invalid state (CSRF attack) or failed token exchange.",
            "status": "pending",
            "testStrategy": "Mock Google token endpoint. Test successful code exchange with valid state. Test CSRF protection by using invalid/expired state. Test error handling for rejected authorization codes. Verify state is deleted after one use (replay protection).",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Extract user info from Google ID token and create/update user in D1",
            "description": "Decode the Google ID token to extract user information (sub, email, name, picture) and create a new user record in D1 or update existing user information.",
            "dependencies": [
              2
            ],
            "details": "Continue callback handler: (1) decode JWT ID token from Google (verify signature using Google's public keys from https://www.googleapis.com/oauth2/v3/certs), (2) extract claims: sub (Google user ID), email, name, picture, (3) query D1 users table by google_id=sub, (4) if user exists, UPDATE display_name, profile_picture_url, updated_at, (5) if new user, INSERT with google_id, email, display_name, profile_picture_url, created_at, updated_at. Return userId for session creation.",
            "status": "pending",
            "testStrategy": "Mock Google ID token with known payload. Test JWT signature verification with valid and invalid signatures. Test new user creation flow. Test existing user update flow. Verify all user fields are correctly extracted and stored. Test handling of missing optional fields (name, picture).",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement JWT session management with signing and verification",
            "description": "Build JWT creation and verification utilities for stateless session management with proper signing using Worker secrets and payload validation.",
            "dependencies": [
              3
            ],
            "details": "Create `src/lib/auth.ts` with functions: (1) `createSessionJWT(userId: string, email: string, secret: string): string` - creates JWT with payload { userId, email, iat: Date.now()/1000, exp: iat + 3600 }, signed with HS256 using Worker secret, (2) `verifySessionJWT(token: string, secret: string): { userId, email } | null` - verifies signature and expiration, returns payload or null if invalid/expired. Use a JWT library compatible with Cloudflare Workers (e.g., jose or @tsndr/cloudflare-worker-jwt).",
            "status": "pending",
            "testStrategy": "Test JWT creation produces valid tokens. Test verification accepts valid tokens and rejects tampered tokens. Test expiration enforcement (expired tokens rejected). Test with different secret keys (wrong secret should fail). Verify JWT payload structure matches specification.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Set up HttpOnly Secure cookies with session JWT and proper security flags",
            "description": "Configure secure cookie handling for session JWTs with HttpOnly, Secure, SameSite=Lax flags to prevent XSS and CSRF attacks.",
            "dependencies": [
              4
            ],
            "details": "In callback handler after JWT creation: (1) set session cookie with name 'session', value=JWT, HttpOnly=true (prevents JavaScript access), Secure=true (HTTPS only), SameSite=Lax (CSRF protection while allowing normal navigation), Max-Age=3600 (1 hour), Path=/, (2) use response.headers.set('Set-Cookie', ...) with properly formatted cookie string. Also store refresh_token from Google in KV with key `refresh:${userId}`, TTL 7 days for future token refresh capability.",
            "status": "pending",
            "testStrategy": "Verify Set-Cookie header includes all security flags (HttpOnly, Secure, SameSite=Lax). Test cookie is sent by browser on subsequent requests. Verify JavaScript cannot access HttpOnly cookie. Test cookie expiration after 1 hour. Test refresh token is stored in KV with correct TTL.",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Implement POST /auth/logout endpoint to clear session",
            "description": "Build logout endpoint that clears the session cookie and removes session data from KV storage to completely terminate user session.",
            "dependencies": [
              5
            ],
            "details": "In `src/routes/auth.ts`, implement POST /auth/logout endpoint that: (1) reads session JWT from cookie, (2) if valid, extract userId and delete refresh token from KV (key `refresh:${userId}`), (3) clear session cookie by setting Set-Cookie with same name, empty value, Max-Age=0, and same Path, Domain, (4) return { success: true, message: 'Logged out successfully' }. Endpoint should work even if JWT is invalid/expired (always clear cookie).",
            "status": "pending",
            "testStrategy": "Test logout clears session cookie. Verify subsequent requests with old cookie are unauthorized. Test that KV refresh token is deleted. Test logout works even with invalid/expired JWT. Verify user must re-authenticate after logout.",
            "parentId": "undefined"
          },
          {
            "id": 7,
            "title": "Implement GET /auth/me endpoint to return current user info",
            "description": "Create endpoint that returns authenticated user's profile information extracted from the session JWT.",
            "dependencies": [
              4
            ],
            "details": "In `src/routes/auth.ts`, implement GET /auth/me endpoint that: (1) uses auth middleware (see subtask 8) to verify JWT and inject user context, (2) queries D1 users table for full user profile by userId from JWT, (3) returns JSON: { userId, email, displayName, profilePictureUrl, createdAt }. If JWT is missing/invalid, middleware returns 401 Unauthorized before reaching handler.",
            "status": "pending",
            "testStrategy": "Test with valid session cookie returns user info. Test without cookie returns 401. Test with expired JWT returns 401. Test with tampered JWT returns 401. Verify returned data matches database user record.",
            "parentId": "undefined"
          },
          {
            "id": 8,
            "title": "Create auth middleware for JWT verification and user context injection",
            "description": "Build reusable middleware that verifies session JWT from cookies and injects authenticated user context into request for protected routes.",
            "dependencies": [
              4
            ],
            "details": "In `src/lib/auth.ts`, create middleware function `requireAuth(handler)` that: (1) extracts session cookie from request.headers.get('Cookie'), (2) parses cookie to get JWT value, (3) calls verifySessionJWT() to validate token, (4) if valid, inject user context into request (e.g., request.user = { userId, email }) and call next handler, (5) if invalid/missing, return 401 response with { error: 'Unauthorized', message: 'Valid session required' }. Export middleware for use in protected routes.",
            "status": "pending",
            "testStrategy": "Test middleware allows requests with valid JWT to proceed. Test middleware blocks requests without JWT (401). Test middleware blocks requests with invalid/expired JWT (401). Test user context is correctly injected. Test middleware can be chained with route handlers.",
            "parentId": "undefined"
          },
          {
            "id": 9,
            "title": "Set up KV storage for session and refresh tokens with TTL",
            "description": "Configure Cloudflare KV namespace bindings for storing OAuth state parameters, refresh tokens, and session invalidation with automatic TTL-based expiration.",
            "dependencies": [],
            "details": "In `wrangler.toml`, add KV namespace binding: [[kv_namespaces]] binding = \"AUTH_KV\", id = \"<production-id>\", preview_id = \"<preview-id>\". Create KV namespace using `wrangler kv:namespace create AUTH_KV`. Update TypeScript types to include AUTH_KV in Env interface. Use KV methods: (1) put(key, value, { expirationTtl: seconds }) for state (300s), refresh tokens (604800s/7 days), (2) get(key) for retrieval, (3) delete(key) for cleanup. Key patterns: `state:${randomId}`, `refresh:${userId}`.",
            "status": "pending",
            "testStrategy": "Test KV namespace is accessible in Worker. Test storing state with 5-minute TTL and verify auto-expiration. Test storing refresh token with 7-day TTL. Test retrieving and deleting values. Verify expired keys return null on retrieval.",
            "parentId": "undefined"
          },
          {
            "id": 10,
            "title": "Create Glass specification files for OAuth and session management",
            "description": "Document the authentication system's intent and contracts in Glass framework format for oauth.glass and session.glass specification files.",
            "dependencies": [
              1,
              2,
              3,
              4,
              5,
              6,
              7,
              8,
              9
            ],
            "details": "Create `glass/auth/oauth.glass` with: Intent: 'User identity verification via Google OAuth 2.0', Contract: 'Guarantees CSRF protection via state parameter, secure authorization code exchange, no credential exposure in URLs/logs, proper error handling for auth failures'. Create `glass/auth/session.glass` with: Intent: 'Stateless session management with JWT', Contract: 'Guarantees JWT integrity via HMAC signature, automatic 1-hour expiration, HttpOnly cookie prevents XSS, SameSite=Lax prevents CSRF, refresh token rotation for extended sessions'. Follow GLASS.md format conventions.",
            "status": "pending",
            "testStrategy": "Verify Glass files follow GLASS.md format. Ensure all security guarantees from implementation are documented. Review contracts match actual implementation behavior. Validate intent statements clearly explain purpose of each auth component.",
            "parentId": "undefined"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 10,
        "expansionPrompt": "Break down OAuth implementation into: (1) implement GET /auth/google endpoint with Google consent redirect and CSRF state parameter, (2) implement GET /auth/callback with code exchange for tokens, (3) extract user info from Google ID token and create/update user in D1, (4) implement JWT session management with signing/verification, (5) set up HttpOnly Secure cookies with proper flags, (6) implement POST /auth/logout to clear session, (7) implement GET /auth/me endpoint, (8) create auth middleware for JWT verification and user context injection, (9) set up KV storage for session/refresh tokens with TTL, (10) create Glass specs for auth/oauth.glass and auth/session.glass"
      },
      {
        "id": "4",
        "title": "Set up Hono router and worker entry point with middleware pipeline",
        "description": "Configure Hono as the routing framework, set up the worker entry point in src/index.ts with CORS, authentication middleware, error handling, and route organization.",
        "details": "Install Hono: `npm install hono`. Create `src/index.ts` as the Worker entry point implementing the fetch handler.\n\nRouter structure:\n```typescript\nconst app = new Hono()\n\n// Global middleware\napp.use('*', cors({ origin: 'https://journalizer.com', credentials: true }))\napp.use('*', errorHandler)\n\n// Public routes\napp.route('/auth', authRoutes)\n\n// Protected routes (require auth)\napp.use('/api/*', authMiddleware)\napp.route('/api/entries', entriesRoutes)\napp.route('/api/media', mediaRoutes)\napp.route('/api/settings', settingsRoutes)\napp.route('/api/reminders', remindersRoutes)\napp.route('/api/export', exportRoutes)\n\n// Webhooks (Twilio signature validation)\napp.route('/api/webhooks', webhooksRoutes)\n\nexport default app\n```\n\nImplement error handler that catches all errors, logs to console, returns structured JSON error responses. Set up proper TypeScript bindings for Cloudflare Workers environment (Env type with D1, R2, KV bindings).\n\nGlass spec:\n- `glass/index.glass` - Intent: HTTP request routing and orchestration; Contract: guarantees authentication on protected routes, CORS headers, structured error responses",
        "testStrategy": "Test with `wrangler dev` and make requests to all route paths. Verify CORS headers in OPTIONS requests. Test that /api/* routes return 401 without valid JWT. Confirm error handler catches and formats errors correctly. Use curl to test each endpoint.",
        "priority": "high",
        "dependencies": [
          "3"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Install Hono and create basic Worker entry point in src/index.ts",
            "description": "Install Hono framework and set up the basic Worker entry point with minimal fetch handler configuration.",
            "dependencies": [],
            "details": "Run `npm install hono` to install the framework. Create `src/index.ts` with a basic Hono app instance and export default fetch handler. Implement minimal structure: `const app = new Hono(); export default app;`. This establishes the foundation for all subsequent middleware and routing configuration.",
            "status": "pending",
            "testStrategy": "Verify Hono is installed in package.json. Test that `wrangler dev` starts successfully and basic fetch handler responds to requests.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Define TypeScript Env type with D1, R2, KV bindings",
            "description": "Create TypeScript type definitions for the Cloudflare Workers environment including all required bindings.",
            "dependencies": [
              1
            ],
            "details": "In `src/index.ts` or separate `src/types/env.ts`, define the Env interface with proper TypeScript bindings: `interface Env { DB: D1Database; MEDIA: R2Bucket; KV: KVNamespace; GOOGLE_CLIENT_ID: string; GOOGLE_CLIENT_SECRET: string; TWILIO_ACCOUNT_SID: string; TWILIO_AUTH_TOKEN: string; TWILIO_PHONE_NUMBER: string; ANTHROPIC_API_KEY: string; DEEPGRAM_API_KEY: string; JWT_SECRET: string; }`. This enables type-safe access to all Cloudflare bindings throughout the application.",
            "status": "pending",
            "testStrategy": "Verify TypeScript compilation with `npm run typecheck`. Ensure all environment bindings have proper types and autocomplete works in IDE.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement global CORS middleware with proper configuration",
            "description": "Configure CORS middleware to allow requests from the Journalizer frontend with credentials support.",
            "dependencies": [
              1
            ],
            "details": "Import `cors` from `hono/cors` and add global CORS middleware: `app.use('*', cors({ origin: 'https://journalizer.com', credentials: true }))`. This ensures all routes respond with proper CORS headers for cross-origin requests from the frontend, including support for cookies and authentication tokens.",
            "status": "pending",
            "testStrategy": "Test with OPTIONS preflight requests using curl. Verify Access-Control-Allow-Origin header is set to https://journalizer.com and Access-Control-Allow-Credentials is true.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement global error handler middleware with structured JSON responses",
            "description": "Create error handling middleware that catches all errors and returns consistent JSON error responses.",
            "dependencies": [
              1
            ],
            "details": "Create error handler middleware function that catches errors, logs them to console with context (request path, method, timestamp), and returns structured JSON responses with format: `{ error: { message: string, code: string, status: number } }`. Add middleware with `app.use('*', errorHandler)`. Handle different error types: validation errors (400), authentication errors (401), not found (404), and internal errors (500).",
            "status": "pending",
            "testStrategy": "Trigger various error scenarios (invalid routes, thrown errors in handlers). Verify all errors return structured JSON with correct status codes. Confirm errors are logged to console with full context.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Set up auth middleware for /api/* protected routes",
            "description": "Implement authentication middleware that validates JWT tokens for all protected API routes.",
            "dependencies": [
              2,
              4
            ],
            "details": "Create `authMiddleware` function (stub implementation for now, full JWT validation will be implemented in Task 3). Middleware should extract JWT from Authorization header, validate token format, and set user context in request. Add to Hono app: `app.use('/api/*', authMiddleware)`. This ensures all /api/* routes require valid authentication before processing requests. Return 401 Unauthorized if token is missing or invalid.",
            "status": "pending",
            "testStrategy": "Test /api/* routes without Authorization header return 401. Test with invalid token format returns 401. Verify middleware runs before route handlers on protected endpoints.",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Configure route organization for all API modules",
            "description": "Set up route structure with placeholder handlers for auth, entries, media, settings, reminders, export, and webhooks routes.",
            "dependencies": [
              3,
              5
            ],
            "details": "Create route files: `src/routes/auth.ts`, `src/routes/entries.ts`, `src/routes/media.ts`, `src/routes/settings.ts`, `src/routes/reminders.ts`, `src/routes/export.ts`, `src/routes/webhooks.ts`. Each exports a Hono app instance with placeholder handlers. In `src/index.ts`, import all route modules and register them: `app.route('/auth', authRoutes)` for public auth routes, then `app.route('/api/entries', entriesRoutes)`, `app.route('/api/media', mediaRoutes)`, `app.route('/api/settings', settingsRoutes)`, `app.route('/api/reminders', remindersRoutes)`, `app.route('/api/export', exportRoutes)`, `app.route('/api/webhooks', webhooksRoutes)` for protected and webhook routes.",
            "status": "pending",
            "testStrategy": "Test each route path returns a response (even if placeholder). Verify /auth/* routes are accessible without auth. Confirm /api/* routes require authentication. Test route organization with curl requests to all endpoints.",
            "parentId": "undefined"
          },
          {
            "id": 7,
            "title": "Create Glass spec for index.glass with routing contract",
            "description": "Document the HTTP routing and orchestration contract in glass/index.glass following Glass Framework conventions.",
            "dependencies": [
              6
            ],
            "details": "Create `glass/index.glass` file documenting: Intent (HTTP request routing and orchestration), Contract (guarantees authentication on protected routes via authMiddleware on /api/*, CORS headers on all responses with origin https://journalizer.com and credentials support, structured error responses with format { error: { message, code, status } }), Inputs (HTTP requests to /auth/*, /api/*, /api/webhooks/*), Outputs (HTTP responses with proper status codes and headers), Dependencies (authMiddleware, errorHandler, CORS middleware), and Error Handling (all errors caught by global errorHandler, returns JSON with appropriate status codes).",
            "status": "pending",
            "testStrategy": "Verify glass/index.glass exists and follows Glass Framework format from GLASS.md. Review contract guarantees match implementation in src/index.ts. Ensure all middleware and routing behavior is documented.",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 7,
        "expansionPrompt": "Break down Hono setup into: (1) install hono and set up basic Worker entry point in src/index.ts, (2) implement global CORS middleware with proper origin and credentials configuration, (3) implement global error handler middleware with structured JSON error responses, (4) set up auth middleware for /api/* protected routes, (5) configure route organization (auth routes, entries, media, settings, reminders, export, webhooks), (6) define TypeScript Env type with D1, R2, KV bindings, (7) create Glass spec for index.glass with routing contract"
      },
      {
        "id": "5",
        "title": "Build R2 media storage service with upload, retrieval, and thumbnail generation",
        "description": "Create a media storage abstraction layer for R2 that handles file uploads, generates thumbnails for images/videos, manages object keys, and provides secure retrieval URLs.",
        "details": "Implement `src/services/media.ts` with functions:\n\n- `uploadMedia(file: File, userId: string, entryId: string): Promise<MediaRecord>` - Generates UUID-based R2 key (format: `{userId}/{entryId}/{uuid}.{ext}`), uploads to R2, stores metadata in D1 media table, returns media record\n- `generateThumbnail(r2Key: string, mediaType: string): Promise<string>` - For images: resize to 300px width using ImageMagick or sharp (via wasm). For videos: extract first frame. Upload thumbnail to R2 with `-thumb` suffix\n- `getMediaUrl(mediaId: string, userId: string): Promise<string>` - Validates user ownership, returns presigned R2 URL or proxied URL through worker\n- `deleteMedia(mediaId: string, userId: string): Promise<void>` - Soft delete (mark in D1, keep in R2 for 30 days before cleanup)\n\nUse R2's presigned URL feature for direct client uploads in web UI. Implement streaming for large file uploads.\n\nGlass spec:\n- `glass/services/media.glass` - Intent: secure binary file storage and retrieval; Contract: guarantees user isolation, file integrity, automatic cleanup, thumbnail generation",
        "testStrategy": "Test uploading various file types (JPEG, PNG, MP3, MP4). Verify R2 keys follow the correct format and files are accessible. Test thumbnail generation for images and videos. Confirm user can only access their own media. Test deletion and verify files remain in R2 for 30 days.",
        "priority": "high",
        "dependencies": [
          "2",
          "4"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement uploadMedia function with UUID-based R2 key generation",
            "description": "Create the core uploadMedia function that accepts File, userId, and entryId parameters, generates a UUID-based R2 object key following the format {userId}/{entryId}/{uuid}.{ext}, and sets up the foundation for file uploads.",
            "dependencies": [],
            "details": "In src/services/media.ts, implement uploadMedia(file: File, userId: string, entryId: string): Promise<MediaRecord>. Generate UUID using crypto.randomUUID(). Extract file extension from file.name or file.type. Construct R2 key as `${userId}/${entryId}/${uuid}.${ext}`. Validate userId and entryId are non-empty. Return structure should include mediaId, r2Key, fileSize, mimeType, createdAt.",
            "status": "pending",
            "testStrategy": "Test UUID generation uniqueness. Verify key format matches {userId}/{entryId}/{uuid}.{ext} pattern. Test with various file extensions (jpg, png, mp4, mp3). Validate error handling for empty userId/entryId.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Handle file streaming and upload to R2",
            "description": "Implement the actual file upload logic to R2 using streaming for large files, utilizing the R2 binding from Cloudflare Workers environment.",
            "dependencies": [
              1
            ],
            "details": "Use env.R2_BUCKET.put(r2Key, fileStream) to upload file to R2. Implement streaming using ReadableStream for files larger than 10MB. Handle R2 upload errors and retry logic with exponential backoff. Set appropriate Content-Type metadata based on file.type. Calculate and store file size and checksum for integrity validation. Use R2's conditional puts to prevent overwrites.",
            "status": "pending",
            "testStrategy": "Test uploading files of various sizes (1KB, 10MB, 100MB). Verify streaming works for large files. Test retry logic with simulated R2 failures. Confirm Content-Type metadata is set correctly. Verify file integrity using checksums.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Store media metadata in D1 media table",
            "description": "After successful R2 upload, persist media metadata to the D1 database media table including all relevant file information and relationships.",
            "dependencies": [
              2
            ],
            "details": "Insert record into D1 media table with fields: id (UUID), userId, entryId, r2Key, fileName, fileSize, mimeType, thumbnailR2Key (nullable), uploadedAt, deletedAt (nullable). Use prepared statements to prevent SQL injection. Transaction handling to ensure atomicity between R2 upload and D1 insert. Return complete MediaRecord object after successful insert. Index on userId and entryId for efficient queries.",
            "status": "pending",
            "testStrategy": "Verify D1 insert with all required fields. Test transaction rollback if D1 insert fails after R2 upload. Confirm userId/entryId indexes improve query performance. Test concurrent uploads from same user. Validate SQL injection prevention.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement thumbnail generation for images using wasm-based processing",
            "description": "Create image thumbnail generation functionality using a wasm-based image processing library compatible with Cloudflare Workers (since sharp requires native modules).",
            "dependencies": [
              2
            ],
            "details": "Research and integrate wasm-based image processing library (e.g., @cf/image or custom wasm module). Implement image resizing to 300px width while maintaining aspect ratio. Support JPEG, PNG, WebP formats. Handle EXIF orientation. Convert output to JPEG with 80% quality for consistent thumbnail sizes. Fetch original image from R2, process in-memory, prepare for upload. Handle errors gracefully for corrupted or unsupported image formats.",
            "status": "pending",
            "testStrategy": "Test thumbnail generation for JPEG, PNG, WebP images. Verify 300px width constraint with various aspect ratios. Test EXIF orientation handling. Confirm output quality and file size. Test with corrupted image files. Validate memory usage stays within Workers limits.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement video thumbnail generation (extract first frame)",
            "description": "Build video thumbnail extraction capability that captures the first frame of video files and converts it to a thumbnail image, working within Cloudflare Workers constraints.",
            "dependencies": [
              2
            ],
            "details": "Investigate Workers-compatible video processing options (may require external service or ffmpeg.wasm). Extract first frame at 1-second mark (not 0 to avoid black frames). Convert frame to JPEG image. Resize to 300px width. For Workers limitations, consider: (1) using Cloudflare Stream API if available, (2) offloading to external service via HTTP, or (3) implementing basic frame extraction with wasm. Support MP4, MOV, AVI formats. Handle videos without decodable frames.",
            "status": "pending",
            "testStrategy": "Test frame extraction from various video formats (MP4, MOV, WebM). Verify frame is captured at 1-second mark. Test with short videos (<1s). Confirm thumbnail dimensions match 300px width. Test with corrupted videos. Validate processing time stays within Workers execution limits.",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Upload thumbnails to R2 with -thumb suffix",
            "description": "Implement the thumbnail upload logic that takes generated thumbnail images and stores them in R2 with a -thumb suffix while updating the media metadata.",
            "dependencies": [
              4,
              5
            ],
            "details": "Create uploadThumbnail helper function. Generate thumbnail R2 key by appending '-thumb' before file extension: `{userId}/{entryId}/{uuid}-thumb.jpg`. Upload thumbnail blob to R2 using same R2 binding. Set Content-Type to image/jpeg. Update D1 media record with thumbnailR2Key. Implement generateThumbnail(r2Key: string, mediaType: string): Promise<string> as main interface that orchestrates image/video thumbnail generation and upload, returning thumbnail R2 key.",
            "status": "pending",
            "testStrategy": "Verify thumbnail R2 key format includes -thumb suffix. Test thumbnail upload for both images and videos. Confirm D1 record updated with thumbnailR2Key. Test generateThumbnail function for various media types. Validate thumbnail accessible via R2 key.",
            "parentId": "undefined"
          },
          {
            "id": 7,
            "title": "Implement getMediaUrl with user ownership validation",
            "description": "Create secure media retrieval function that validates user ownership before providing access to media files, preventing unauthorized access.",
            "dependencies": [
              3
            ],
            "details": "Implement getMediaUrl(mediaId: string, userId: string): Promise<string>. Query D1 media table for mediaId and verify userId matches and deletedAt IS NULL. Return 403 error if ownership validation fails. Return 404 if media not found. After validation, proceed to generate presigned URL or proxy URL. Log access attempts in processing_log for security audit. Consider caching validation results in KV with short TTL (5 minutes).",
            "status": "pending",
            "testStrategy": "Test user can only access their own media. Verify 403 error for unauthorized access attempts. Test 404 for non-existent mediaId. Confirm deleted media (deletedAt set) returns 404. Test with various userId/mediaId combinations. Validate audit logs capture access attempts.",
            "parentId": "undefined"
          },
          {
            "id": 8,
            "title": "Implement R2 presigned URL generation",
            "description": "Generate secure, time-limited presigned URLs for R2 objects that allow direct client access without exposing R2 credentials.",
            "dependencies": [
              7
            ],
            "details": "Use R2 binding's presigned URL capability (env.R2_BUCKET.createSignedUrl()). Set expiration to 1 hour (3600 seconds) for balance between usability and security. Include thumbnail URL in response if thumbnailR2Key exists. For direct client uploads from web UI, implement createUploadUrl(userId: string, entryId: string, fileName: string): Promise<{ uploadUrl: string, r2Key: string }> that returns presigned upload URL. Handle CORS headers appropriately for browser access.",
            "status": "pending",
            "testStrategy": "Test presigned URLs expire after configured time. Verify URLs work in browser without authentication. Test upload URLs allow file uploads. Confirm CORS headers allow cross-origin requests. Test thumbnail URLs when thumbnailR2Key exists. Validate URL security by attempting access after expiration.",
            "parentId": "undefined"
          },
          {
            "id": 9,
            "title": "Implement deleteMedia with soft delete logic",
            "description": "Create soft delete functionality that marks media as deleted in D1 while keeping files in R2 for 30-day retention period before permanent cleanup.",
            "dependencies": [
              3
            ],
            "details": "Implement deleteMedia(mediaId: string, userId: string): Promise<void>. Validate user ownership (reuse validation logic from getMediaUrl). Update D1 media record: SET deletedAt = CURRENT_TIMESTAMP WHERE id = mediaId. Do NOT delete from R2 immediately. Mark both original file and thumbnail for deletion. Log deletion event in processing_log. Return success after D1 update. Deleted media should not appear in getMediaUrl queries (check deletedAt IS NULL).",
            "status": "pending",
            "testStrategy": "Test soft delete sets deletedAt timestamp. Verify user ownership validation before deletion. Confirm deleted media not accessible via getMediaUrl. Test deleting media with and without thumbnails. Validate users cannot delete others' media. Verify R2 files remain after soft delete.",
            "parentId": "undefined"
          },
          {
            "id": 10,
            "title": "Set up 30-day R2 cleanup strategy",
            "description": "Implement automated cleanup process that permanently removes soft-deleted media files from R2 after 30-day retention period.",
            "dependencies": [
              9
            ],
            "details": "Create scheduled Cloudflare Worker cron trigger (daily at 2 AM UTC) in wrangler.toml. Implement cleanup function in src/jobs/cleanup-media.ts. Query D1 for media where deletedAt < NOW() - INTERVAL 30 DAYS. Batch delete from R2 (max 100 per run to avoid timeout). Delete both original file and thumbnail. Delete D1 records after successful R2 deletion. Log cleanup operations. Consider R2 lifecycle policies as alternative or supplement. Add retry logic for failed deletions.",
            "status": "pending",
            "testStrategy": "Test cron trigger fires at scheduled time. Verify only media older than 30 days deleted. Test batch deletion with >100 files. Confirm both R2 files and D1 records removed. Test retry logic with simulated R2 failures. Validate cleanup logs. Test manual invocation for debugging.",
            "parentId": "undefined"
          },
          {
            "id": 11,
            "title": "Implement streaming for large file uploads",
            "description": "Optimize file upload handling for large media files using streaming to avoid memory issues and timeouts in Cloudflare Workers environment.",
            "dependencies": [
              2
            ],
            "details": "Enhance uploadMedia to use ReadableStream for files >10MB. Implement chunked upload using R2's multipart upload API for files >100MB. Use TransformStream to process chunks without loading entire file in memory. Set appropriate Worker timeout considerations (max 30s for free tier, 15min for paid). Progress tracking using request context. Handle abort scenarios. For client-side, use presigned upload URLs to bypass Worker entirely for very large files (>100MB), uploading directly from browser to R2.",
            "status": "pending",
            "testStrategy": "Test uploading 1MB, 10MB, 50MB, 150MB files. Verify memory usage stays <128MB. Test chunked upload for files >100MB. Confirm upload continues if one chunk fails (retry). Test abort scenarios. Validate presigned upload URLs work for direct browser uploads. Monitor Worker execution time.",
            "parentId": "undefined"
          },
          {
            "id": 12,
            "title": "Create Glass spec for services/media.glass with security contracts",
            "description": "Document the media service in Glass framework format, defining intent, contract, security guarantees, and implementation specifications.",
            "dependencies": [
              1,
              2,
              3,
              6,
              7,
              8,
              9,
              10,
              11
            ],
            "details": "Create glass/services/media.glass file following Glass framework conventions from GLASS.md. Define Intent: 'Secure binary file storage and retrieval with user isolation and automatic lifecycle management'. Contract: 'Guarantees user isolation (users can only access own media), file integrity (checksums), automatic cleanup (30-day soft delete), thumbnail generation (images/videos), secure access (presigned URLs), streaming support (large files)'. Document all public functions: uploadMedia, generateThumbnail, getMediaUrl, deleteMedia. Specify error conditions, security boundaries, and performance characteristics. Reference R2 and D1 bindings.",
            "status": "pending",
            "testStrategy": "Validate Glass spec syntax against GLASS.md format. Verify all public functions documented. Confirm security contracts match implementation. Review intent clarity. Test that documented error conditions are comprehensive. Validate contract guarantees are testable.",
            "parentId": "undefined"
          }
        ],
        "complexity": 8,
        "recommendedSubtasks": 12,
        "expansionPrompt": "Break down R2 media service into: (1) implement uploadMedia function with UUID-based R2 key generation, (2) handle file streaming and upload to R2, (3) store media metadata in D1 media table, (4) implement thumbnail generation for images using wasm-based image processing, (5) implement video thumbnail generation (extract first frame), (6) upload thumbnails to R2 with -thumb suffix, (7) implement getMediaUrl with user ownership validation, (8) implement R2 presigned URL generation, (9) implement deleteMedia with soft delete logic, (10) set up 30-day R2 cleanup strategy, (11) implement streaming for large file uploads, (12) create Glass spec for services/media.glass with security contracts"
      },
      {
        "id": "6",
        "title": "Integrate Anthropic Claude API for journal entry text polishing",
        "description": "Implement AI text refinement using Claude API (Haiku model for cost efficiency) that polishes raw journal entries while preserving the user's authentic voice and applying user-specific voice style preferences.",
        "details": "Create `src/services/ai.ts` with:\n\n```typescript\nasync function polishEntry(rawText: string, userPreferences: VoicePreferences): Promise<string>\n```\n\nUse Claude 3 Haiku via Anthropic API. System prompt (from PRD section 8.2):\n```\nYou are a journal editor. Your job is to take a raw journal entry and lightly polish it for readability. Rules:\n- Keep the author's voice, words, and personality intact\n- Fix obvious typos, grammar, and punctuation\n- Add paragraph breaks where natural\n- Do NOT add content the author didn't write\n- Do NOT change the meaning or tone\n- The result should read like a natural journal entry, not a blog post\n- Voice style preference: ${user.voiceStyle}\n- Additional voice notes: ${user.voiceNotes}\n```\n\nSupport voice styles: natural (minimal), conversational (light cleanup), reflective (structured), polished (thorough). Include user's custom voice notes from settings.\n\nImplement retry logic with exponential backoff. Log all API calls to processing_log table. Handle rate limits gracefully.\n\nGlass spec:\n- `glass/services/ai.glass` - Intent: enhance readability while preserving authenticity; Contract: guarantees no content addition, voice preservation, idempotency, failure recovery",
        "testStrategy": "Test with various raw inputs: typos, run-on sentences, stream-of-consciousness text. Verify output maintains user's words and tone. Test all voice style options. Mock API failures and verify retry logic. Measure latency and cost per request. Validate that personal info is not leaked in logs.",
        "priority": "high",
        "dependencies": [
          "2",
          "4"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Set up Anthropic API client and implement basic polishEntry function",
            "description": "Create src/services/ai.ts with Anthropic SDK integration, API key configuration from environment, and skeleton polishEntry function that accepts rawText and userPreferences parameters.",
            "dependencies": [],
            "details": "Install @anthropic-ai/sdk package. Create ai.ts service file with proper TypeScript types for VoicePreferences interface (voiceStyle: 'natural' | 'conversational' | 'reflective' | 'polished', voiceNotes?: string). Initialize Anthropic client with API key from env.ANTHROPIC_API_KEY. Implement basic polishEntry function signature that returns a Promise<string>. Use Claude 3 Haiku model (claude-3-haiku-20240307) for cost efficiency.",
            "status": "pending",
            "testStrategy": "Mock Anthropic API and verify client initialization. Test function accepts correct parameters and returns string promise. Validate API key is read from environment variables.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement dynamic system prompt construction based on voice preferences",
            "description": "Build prompt builder that generates the system prompt dynamically by incorporating user's voice style preference and custom voice notes into the base journal editor prompt.",
            "dependencies": [
              1
            ],
            "details": "Create buildSystemPrompt(userPreferences: VoicePreferences): string helper function. Start with base prompt: 'You are a journal editor. Your job is to take a raw journal entry and lightly polish it for readability. Rules: - Keep the author's voice, words, and personality intact - Fix obvious typos, grammar, and punctuation - Add paragraph breaks where natural - Do NOT add content the author didn't write - Do NOT change the meaning or tone - The result should read like a natural journal entry, not a blog post'. Append voice style guidance and user's custom voice notes to the system prompt.",
            "status": "pending",
            "testStrategy": "Test prompt generation with all 4 voice styles. Verify custom voice notes are properly included. Assert prompt maintains core rules while adding user preferences.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement voice style logic for natural, conversational, reflective, and polished modes",
            "description": "Define specific guidance text for each of the four voice style options that will be injected into the system prompt to control the level of polish applied by Claude.",
            "dependencies": [
              2
            ],
            "details": "Create voice style mapping: 'natural' = minimal changes, only fix obvious errors; 'conversational' = light cleanup, maintain casual tone; 'reflective' = add structure and paragraph breaks, thoughtful tone; 'polished' = thorough editing for clarity and flow. Implement getVoiceStyleGuidance(style: VoiceStyle): string function that returns appropriate guidance text. This text instructs Claude on how aggressively to polish based on user preference.",
            "status": "pending",
            "testStrategy": "Test each voice style produces appropriate guidance text. Verify natural mode produces minimal edits, polished mode produces more thorough edits. Compare outputs for same input across all styles.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Integrate user custom voice notes into prompt generation",
            "description": "Extend prompt builder to safely incorporate user's custom voice notes (free-form text preferences) into the system prompt without breaking prompt structure or enabling prompt injection.",
            "dependencies": [
              2
            ],
            "details": "Modify buildSystemPrompt to append user.voiceNotes if present. Add section: 'Additional voice notes from user: ${userPreferences.voiceNotes}'. Sanitize voice notes to prevent prompt injection (though Claude API has built-in protections). Handle null/undefined voice notes gracefully. Ensure voice notes are clearly delineated in prompt to prevent confusion with core instructions.",
            "status": "pending",
            "testStrategy": "Test with various voice notes including empty, long text, special characters. Verify notes are properly incorporated. Test that malicious prompt injection attempts don't compromise core instructions.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement retry logic with exponential backoff for API failures",
            "description": "Add robust retry mechanism that handles transient API failures using exponential backoff strategy with configurable max retries and backoff multiplier.",
            "dependencies": [
              1
            ],
            "details": "Create retry wrapper function withRetry<T>(fn: () => Promise<T>, options: RetryOptions): Promise<T>. Implement exponential backoff: first retry after 1s, second after 2s, third after 4s, etc. Max 3 retries by default. Retry on network errors, 5xx status codes, and rate limit errors (429). Don't retry on 4xx client errors (except 429). Use Anthropic SDK's error types to distinguish error categories. Add jitter to prevent thundering herd.",
            "status": "pending",
            "testStrategy": "Mock API failures and verify retry behavior. Test exponential backoff timing. Verify 4xx errors aren't retried. Test max retries limit. Validate jitter adds randomness to backoff.",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Implement rate limit handling for Anthropic API",
            "description": "Add graceful handling of rate limit responses (429 status) from Anthropic API, respecting Retry-After headers and providing informative errors when rate limits are exhausted.",
            "dependencies": [
              5
            ],
            "details": "Check for 429 status code in API responses. Read Retry-After header if present and wait specified duration before retrying. If rate limit persists after retries, throw RateLimitError with clear message. Consider implementing client-side rate limiting to prevent hitting API limits. Track rate limit events in logs. Return user-friendly error message: 'AI service temporarily unavailable due to high demand, please try again shortly'.",
            "status": "pending",
            "testStrategy": "Mock 429 responses with various Retry-After values. Verify system respects retry delays. Test behavior when rate limit persists. Validate user receives appropriate error message.",
            "parentId": "undefined"
          },
          {
            "id": 7,
            "title": "Log all API calls to processing_log table without exposing PII",
            "description": "Implement comprehensive logging of AI API operations to D1 processing_log table, tracking costs, latency, token usage, and errors while ensuring no personally identifiable information is logged.",
            "dependencies": [
              1
            ],
            "details": "Create logProcessing(type: 'ai_polish', userId: string, metadata: ProcessingMetadata) helper that inserts to processing_log table. Log: operation type, user_id (UUID only, no email/name), timestamp, duration_ms, tokens_used (from API response), estimated_cost (tokens * price per token), status (success/failure), error_message if failed. DO NOT log: raw entry text, polished text, user voice notes, any content. Store only metadata: text length, model used, voice style selected.",
            "status": "pending",
            "testStrategy": "Verify logs contain required metadata fields. Assert no PII (email, names, journal content) appears in logs. Test successful and failed operations are logged. Validate cost calculations are accurate.",
            "parentId": "undefined"
          },
          {
            "id": 8,
            "title": "Implement cost and latency tracking for AI operations",
            "description": "Add monitoring and metrics collection for AI API usage including token consumption, cost per request, response latency, and aggregate statistics for budget management.",
            "dependencies": [
              7
            ],
            "details": "Track usage metrics: input_tokens, output_tokens from API response. Calculate cost: Haiku pricing is ~$0.25 per 1M input tokens, ~$1.25 per 1M output tokens (verify current pricing). Store in processing_log. Add latency tracking: measure time from API call to response. Create helper getCostEstimate(inputTokens: number, outputTokens: number): number. Consider adding aggregate queries for daily/monthly cost reporting. Set up alerts if costs exceed thresholds.",
            "status": "pending",
            "testStrategy": "Verify token counts are captured from API responses. Test cost calculations with known token counts. Validate latency measurements are accurate. Test aggregate cost queries return correct totals.",
            "parentId": "undefined"
          },
          {
            "id": 9,
            "title": "Create Glass spec for services/ai.glass with voice preservation contract",
            "description": "Document the AI service contract in Glass format specifying intent, guarantees (no content addition, voice preservation, idempotency), failure modes, and verification strategy.",
            "dependencies": [
              1,
              2,
              3,
              4,
              5,
              6,
              7,
              8
            ],
            "details": "Create glass/services/ai.glass file following GLASS.md format. Intent: Enhance journal entry readability while preserving authentic voice. Contract guarantees: (1) No content addition - output only contains words/ideas from input, (2) Voice preservation - maintains author's tone, style, personality, (3) Idempotency - same input + preferences = same output, (4) Failure recovery - retries transient errors, (5) Privacy - no PII logged. Define invariants, edge cases, and testing strategy. Document voice style behavior matrix. Specify how to verify AI didn't add content (e.g., word-level diff analysis showing only edits, not additions).",
            "status": "pending",
            "testStrategy": "Review Glass spec against PRD requirements. Verify all contracts are testable. Create test cases that validate each guarantee (especially no content addition). Ensure verification strategy is documented and implementable.",
            "parentId": "undefined"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 9,
        "expansionPrompt": "Break down AI integration into: (1) implement polishEntry function with Anthropic API client setup, (2) construct dynamic system prompt based on user voice preferences, (3) implement voice style logic (natural, conversational, reflective, polished), (4) integrate user's custom voice notes into prompt, (5) implement retry logic with exponential backoff for API failures, (6) implement rate limit handling, (7) log all API calls to processing_log table (without PII), (8) implement cost and latency tracking, (9) create Glass spec for services/ai.glass with voice preservation contract"
      },
      {
        "id": "7",
        "title": "Integrate Deepgram Nova-3 API for audio and video transcription",
        "description": "Implement speech-to-text transcription service using Deepgram Nova-3 that processes audio and video files, generates accurate transcriptions with punctuation and paragraphs, and handles long-form content.",
        "details": "Create `src/services/transcription.ts`:\n\n```typescript\nasync function transcribeMedia(r2Key: string, mediaType: 'audio' | 'video'): Promise<TranscriptionResult>\n```\n\nProcess flow:\n1. Download media file from R2 (stream for large files)\n2. For video: extract audio track using FFmpeg (via wasm or separate extraction step)\n3. Send to Deepgram Nova-3 pre-recorded API with options: punctuation=true, paragraphs=true, diarize=true (speaker detection)\n4. Parse response and extract transcript text\n5. Return { transcript: string, confidence: number, duration: number, words: Word[] }\n\nUse Deepgram's JavaScript SDK. Cost: ~$0.0043/minute. Store transcription in media.transcription column. Handle failures gracefully (poor audio quality, unsupported formats).\n\nGlass spec:\n- `glass/services/transcription.glass` - Intent: convert speech to text for journal entries; Contract: guarantees punctuation, speaker diarization, timestamp accuracy, failure on unsupported formats",
        "testStrategy": "Test with clear audio (voice memo), noisy audio (background noise), multi-speaker audio, various accents. Test video files and verify audio extraction. Measure accuracy on test set. Test handling of very long files (>30 min). Verify cost tracking in processing_log.",
        "priority": "high",
        "dependencies": [
          "5"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Set up Deepgram SDK and create transcription service skeleton",
            "description": "Install Deepgram JavaScript SDK, create src/services/transcription.ts with TypeScript interfaces for TranscriptionResult, Word, and the main transcribeMedia function signature.",
            "dependencies": [],
            "details": "Install @deepgram/sdk package. Create src/services/transcription.ts with types: TranscriptionResult { transcript: string, confidence: number, duration: number, words: Word[] }, Word { word: string, start: number, end: number, confidence: number, speaker?: number }. Add Deepgram API key to wrangler.toml environment bindings. Initialize Deepgram client with API key from environment.",
            "status": "pending",
            "testStrategy": "Verify Deepgram client initializes correctly with valid API key. Test that invalid API key throws appropriate error.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement R2 media download with streaming for large files",
            "description": "Create function to download media files from R2 bucket with streaming support to handle large audio/video files efficiently in Workers environment.",
            "dependencies": [
              1
            ],
            "details": "Implement downloadMediaFromR2(r2Key: string): Promise<ReadableStream> that retrieves file from R2 bucket. Use R2 bucket.get() with streaming. Handle cases where file doesn't exist (return error). For files >10MB, ensure streaming is used to avoid memory limits. Add content-type detection to validate media type.",
            "status": "pending",
            "testStrategy": "Test downloading small (<5MB) and large (>50MB) audio files. Verify streaming prevents memory overflow. Test error handling for non-existent R2 keys.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Research and implement FFmpeg solution for video audio extraction",
            "description": "Evaluate and implement FFmpeg-based audio extraction from video files, either using FFmpeg.wasm in Workers or an external service approach.",
            "dependencies": [
              1
            ],
            "details": "Research options: (1) @ffmpeg/ffmpeg wasm library in Workers, (2) external microservice with FFmpeg binary, (3) Cloudflare Queues + Durable Objects for heavy processing. Due to Workers 128MB memory limit and CPU constraints, likely need external service or Queue-based approach. Implement extractAudioFromVideo(videoStream: ReadableStream): Promise<ReadableStream> that returns audio-only stream. Support common video formats: MP4, MOV, WEBM.",
            "status": "pending",
            "testStrategy": "Test with MP4, MOV, and WEBM video files. Verify audio extraction preserves quality. Measure processing time and memory usage. Test failure on unsupported formats.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Integrate Deepgram Nova-3 pre-recorded API with required features",
            "description": "Implement the core Deepgram API integration using pre-recorded transcription endpoint with punctuation, paragraphs, and speaker diarization enabled.",
            "dependencies": [
              1,
              2
            ],
            "details": "Create sendToDeepgram(audioStream: ReadableStream, options): Promise<DeepgramResponse> function. Configure Deepgram options: { punctuate: true, paragraphs: true, diarize: true, model: 'nova-2' (or latest Nova-3), smart_format: true }. Handle streaming audio upload to Deepgram. Use prerecorded.transcribeFile() method from SDK. Set appropriate timeout (5+ minutes for long files).",
            "status": "pending",
            "testStrategy": "Test with clear single-speaker audio, multi-speaker conversations, noisy background audio. Verify punctuation and paragraph breaks are present. Confirm speaker labels in diarized output. Test various audio formats (WAV, MP3, M4A).",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Parse Deepgram response and extract transcript data",
            "description": "Implement response parsing logic to extract transcript text, confidence scores, duration, word-level timestamps, and speaker information from Deepgram API response.",
            "dependencies": [
              4
            ],
            "details": "Create parseDeepgramResponse(response): TranscriptionResult function. Extract: (1) transcript text from response.results.channels[0].alternatives[0].transcript, (2) confidence score (average word confidences), (3) duration from metadata, (4) words array with timestamps and speaker labels. Handle multiple speakers in diarized output. Calculate overall confidence as weighted average. Format paragraphs from Deepgram's paragraph markers.",
            "status": "pending",
            "testStrategy": "Test parsing single-speaker and multi-speaker responses. Verify confidence calculation accuracy. Test with responses containing paragraphs. Validate Word array has correct start/end timestamps.",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Implement long-form content handling for files >30 minutes",
            "description": "Add support for transcribing long audio/video files (>30 minutes) by handling Deepgram's processing time limits and implementing chunking or polling strategies if needed.",
            "dependencies": [
              4
            ],
            "details": "Deepgram pre-recorded API supports long files but may take time to process. Implement timeout handling with retries. For files >1 hour, consider: (1) using Deepgram's callback URL feature for async processing, (2) implementing progress tracking in processing_log, (3) setting Workers timeout appropriately or using Durable Objects for long-running tasks. Add file duration estimation before transcription.",
            "status": "pending",
            "testStrategy": "Test with 30-minute, 60-minute, and 90-minute audio files. Measure processing time. Verify timeout handling doesn't fail prematurely. Test callback/polling mechanism if implemented.",
            "parentId": "undefined"
          },
          {
            "id": 7,
            "title": "Implement comprehensive error handling for audio quality and format issues",
            "description": "Add error handling for poor audio quality, unsupported formats, Deepgram API failures, and network timeouts with appropriate user-facing error messages.",
            "dependencies": [
              4,
              5
            ],
            "details": "Handle error cases: (1) unsupported format - validate file extension/MIME type before processing, (2) poor audio quality - check Deepgram confidence scores, return warning if <0.6 average, (3) API failures - retry with exponential backoff (max 3 retries), (4) network timeouts - set reasonable timeout (10min default), (5) API rate limits - return 429 with retry-after. Create custom error types: TranscriptionError, UnsupportedFormatError, PoorQualityWarning. Log all errors to processing_log.",
            "status": "pending",
            "testStrategy": "Test with corrupted audio files, unsupported formats (.avi), extremely noisy audio. Simulate API failures and timeouts. Verify appropriate error messages returned. Test retry logic with intermittent failures.",
            "parentId": "undefined"
          },
          {
            "id": 8,
            "title": "Store transcription results in D1 media.transcription column",
            "description": "Implement database update logic to save transcription text, confidence score, and metadata to the media table after successful transcription.",
            "dependencies": [
              5
            ],
            "details": "Update media table: SET transcription = ?, transcription_confidence = ?, transcription_duration = ?, processed_at = CURRENT_TIMESTAMP WHERE id = ?. Store full transcript in transcription column (TEXT type). Optionally store word-level data as JSON in separate column or related table for future features (word search, timestamp navigation). Update processing_log with success status and cost.",
            "status": "pending",
            "testStrategy": "Verify transcription is saved correctly after processing. Test with various transcript lengths (short <1min, long >30min). Confirm confidence and duration are stored. Query database to verify data integrity.",
            "parentId": "undefined"
          },
          {
            "id": 9,
            "title": "Implement cost tracking in processing_log table",
            "description": "Add cost calculation and logging for each transcription request to track Deepgram API usage and expenses in the processing_log table.",
            "dependencies": [
              5
            ],
            "details": "Calculate cost: duration_minutes * $0.0043 (Deepgram Nova-3 rate). Insert into processing_log: { user_id, media_id, operation_type: 'transcription', provider: 'deepgram', model: 'nova-3', input_duration: seconds, cost_usd: calculated_cost, status: 'success'|'failed', error_message?, created_at }. Track cumulative costs per user for billing/monitoring. Add cost field to TranscriptionResult return type.",
            "status": "pending",
            "testStrategy": "Verify cost calculation accuracy for various file durations. Test that successful and failed transcriptions are logged. Query processing_log to validate cost tracking. Test cumulative cost calculation for users with multiple transcriptions.",
            "parentId": "undefined"
          },
          {
            "id": 10,
            "title": "Create Glass specification for transcription service",
            "description": "Write glass/services/transcription.glass following Glass Framework methodology to document the transcription service's intent, contract, state management, and error scenarios.",
            "dependencies": [
              1,
              2,
              3,
              4,
              5,
              6,
              7,
              8,
              9
            ],
            "details": "Create glass/services/transcription.glass with: Intent - convert speech to text for journal entries with high accuracy; Contract - guarantees punctuation, speaker diarization when multiple speakers detected, word-level timestamp accuracy 100ms, failure on unsupported formats with clear error messages; State - processes media from R2, updates D1 media table; Errors - UnsupportedFormatError, PoorQualityWarning (confidence <0.6), ApiTimeoutError, RateLimitError; Dependencies - Deepgram Nova-3 API, R2 storage, D1 database; Performance - <30s for 5min audio, <5min for 60min audio.",
            "status": "pending",
            "testStrategy": "Review Glass spec against implementation. Verify all contracts are testable. Ensure error scenarios are documented and match implementation.",
            "parentId": "undefined"
          },
          {
            "id": 11,
            "title": "Integrate transcribeMedia into main workflow and add end-to-end tests",
            "description": "Wire up the transcription service to the media upload workflow, implement the complete transcribeMedia function orchestrating all components, and create comprehensive end-to-end tests.",
            "dependencies": [
              2,
              3,
              4,
              5,
              6,
              7,
              8,
              9
            ],
            "details": "Complete transcribeMedia(r2Key: string, mediaType: 'audio' | 'video'): Promise<TranscriptionResult> orchestration: (1) download from R2, (2) extract audio if video, (3) send to Deepgram, (4) parse response, (5) store in D1, (6) log cost. Add to media processing pipeline (likely called after upload). Handle race conditions if multiple workers process same file. Add API endpoint POST /api/media/:id/transcribe for manual retranscription. Create integration tests with real Deepgram API (test mode) covering all scenarios.",
            "status": "pending",
            "testStrategy": "End-to-end test: upload audio file, trigger transcription, verify database update. Test video file end-to-end with audio extraction. Test with clear audio, noisy audio, multi-speaker, different accents. Verify >30min file handling. Test manual retranscription endpoint. Measure total latency and cost accuracy.",
            "parentId": "undefined"
          }
        ],
        "complexity": 8,
        "recommendedSubtasks": 11,
        "expansionPrompt": "Break down transcription service into: (1) implement transcribeMedia function with Deepgram client setup, (2) download media from R2 with streaming for large files, (3) implement video audio extraction (FFmpeg wasm or separate service), (4) send audio to Deepgram Nova-3 API with punctuation/paragraphs/diarization options, (5) parse Deepgram response and extract transcript/confidence/duration/words, (6) handle long-form content (>30 min files), (7) implement error handling for poor audio quality, (8) handle unsupported format failures, (9) store transcription in D1 media.transcription column, (10) implement cost tracking in processing_log, (11) create Glass spec for services/transcription.glass"
      },
      {
        "id": "8",
        "title": "Build journal entries API with CRUD operations and pagination",
        "description": "Implement REST API endpoints for creating, reading, updating, and deleting journal entries with support for filtering, pagination, search, and media attachments.",
        "details": "Create `src/routes/api/entries.ts` with endpoints:\n\n- GET /api/entries - List entries with query params: page, limit (default 20), startDate, endDate, type (text/audio/video/photo), source (sms/web), search (full-text). Return paginated results with total count\n- GET /api/entries/:id - Get single entry with all media attachments, includes both raw and polished content\n- POST /api/entries - Create new entry from web. Body: { rawContent, entryDate, tags?, mood?, location?, mediaIds[]?, polishWithAI: boolean }. If polishWithAI=true, send to AI service asynchronously\n- PUT /api/entries/:id - Update entry (only polished_content, tags, mood editable)\n- DELETE /api/entries/:id - Soft delete (mark deleted in entries table, cascade to media)\n\nAll operations filtered by userId from JWT. Validate entryDate is not in future. Use Zod for request validation.\n\nGlass spec:\n- `glass/routes/entries.glass` - Intent: expose journal entry management to users; Contract: guarantees user isolation, input validation, pagination correctness, atomic operations",
        "testStrategy": "Test CRUD operations with authenticated requests. Verify pagination works correctly with different page sizes. Test filtering by date range, type, source. Verify users cannot access others' entries. Test search functionality. Validate error responses for invalid inputs.",
        "priority": "high",
        "dependencies": [
          "4",
          "6"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement GET /api/entries with pagination (page, limit params)",
            "description": "Create the base endpoint for listing journal entries with pagination support using page and limit query parameters (default limit: 20)",
            "dependencies": [],
            "details": "Create `src/routes/api/entries.ts` and implement GET /api/entries endpoint. Accept query params: page (default 1), limit (default 20, max 100). Query entries table with OFFSET and LIMIT. Return { entries: [], pagination: { page, limit, total, totalPages } }. Use Drizzle ORM for type-safe queries. Ensure userId filtering is applied (from JWT context).",
            "status": "pending",
            "testStrategy": "Test with various page/limit combinations. Verify correct offset calculation (offset = (page-1) * limit). Test edge cases: page=0, negative values, limit exceeding max. Verify total count is accurate.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Add filtering by date range (startDate, endDate)",
            "description": "Extend GET /api/entries to support filtering entries by date range using startDate and endDate query parameters",
            "dependencies": [
              1
            ],
            "details": "Add optional query params: startDate, endDate (ISO 8601 format). Parse dates and validate format using Zod. Add WHERE clause: entry_date >= startDate AND entry_date <= endDate. Handle timezone considerations (store as UTC, filter inclusively). Return 400 if startDate > endDate or dates are invalid.",
            "status": "pending",
            "testStrategy": "Test with various date ranges. Verify boundary conditions (same start/end date, wide ranges, future dates). Test invalid date formats return 400. Verify entries on boundary dates are included correctly.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Add filtering by type and source",
            "description": "Extend GET /api/entries to support filtering by entry type (text/audio/video/photo) and source (sms/web)",
            "dependencies": [
              2
            ],
            "details": "Add optional query params: type (text|audio|video|photo), source (sms|web). Validate using Zod enums matching DB schema. Add WHERE clauses for type and source when provided. Support multiple values (comma-separated or array). Combine with existing date and pagination filters using AND logic.",
            "status": "pending",
            "testStrategy": "Test filtering by type only, source only, and combined. Test invalid enum values return 400. Verify filtering works correctly with pagination. Test edge case: no entries match filters (return empty array with total=0).",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement full-text search functionality",
            "description": "Add full-text search capability to GET /api/entries endpoint, searching across raw_content and polished_content fields",
            "dependencies": [
              3
            ],
            "details": "Add optional query param: search (string). Implement using SQLite FTS5 virtual table or LIKE queries. Create FTS5 table `entries_fts` with triggers to sync with entries table. Search both raw_content and polished_content. Use ranking for relevance. If FTS5 not available in D1, use: WHERE (raw_content LIKE '%searchTerm%' OR polished_content LIKE '%searchTerm%'). Sanitize input to prevent SQL injection.",
            "status": "pending",
            "testStrategy": "Test search with single words, phrases, special characters. Verify ranking/relevance order. Test search combined with other filters (date, type, source). Test empty search term returns all entries. Verify performance with large datasets.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement GET /api/entries/:id with media attachments",
            "description": "Create endpoint to retrieve a single journal entry by ID, including all associated media attachments with raw and polished content",
            "dependencies": [
              1
            ],
            "details": "Implement GET /api/entries/:id. Validate UUID format using Zod. Query entries table by id and userId (ensure user isolation). JOIN with media table to fetch all attachments. Return: { id, rawContent, polishedContent, entryDate, type, source, mood, tags, location, createdAt, updatedAt, media: [{ id, type, url, transcription, thumbnailUrl }] }. Return 404 if not found or belongs to different user.",
            "status": "pending",
            "testStrategy": "Test with valid entry ID. Test with invalid UUID format (400). Test with non-existent ID (404). Test accessing another user's entry (404). Verify all media attachments are included. Test entry with no media returns empty media array.",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Implement POST /api/entries with Zod validation",
            "description": "Create endpoint for creating new journal entries from web interface with comprehensive input validation using Zod schemas",
            "dependencies": [
              1
            ],
            "details": "Implement POST /api/entries. Define Zod schema: { rawContent: string (required), entryDate: ISO date (required, not future), tags: string[] (optional), mood: string (optional), location: string (optional), mediaIds: UUID[] (optional), polishWithAI: boolean (default false) }. Validate entryDate is not in future. Generate entry ID (UUID). Insert into entries table with type='text', source='web', userId from JWT. Verify mediaIds belong to user if provided. Return 201 with created entry.",
            "status": "pending",
            "testStrategy": "Test valid entry creation. Test missing required fields (400). Test future entryDate (400). Test invalid UUID in mediaIds (400). Test mediaIds belonging to other users (403). Verify entry is created with correct userId isolation.",
            "parentId": "undefined"
          },
          {
            "id": 7,
            "title": "Integrate async AI polish when polishWithAI=true",
            "description": "Add asynchronous AI polishing workflow when creating entries with polishWithAI flag enabled",
            "dependencies": [
              6
            ],
            "details": "When polishWithAI=true in POST /api/entries: (1) Create entry with polished_content=null, (2) Add record to processing_log table with operation='ai_polish', status='pending', (3) Trigger async Worker/Queue job to call AI service (OpenAI/Anthropic), (4) Update entry.polished_content when complete, (5) Update processing_log status='completed'/'failed'. Use Cloudflare Queues or Durable Objects for async processing. Return 201 immediately without waiting for AI.",
            "status": "pending",
            "testStrategy": "Test entry created with polishWithAI=true returns immediately with polished_content=null. Mock AI service to test successful polish. Test AI failure updates processing_log with error. Verify async job updates entry correctly. Test rate limiting on AI calls.",
            "parentId": "undefined"
          },
          {
            "id": 8,
            "title": "Implement PUT /api/entries/:id for editing polished content/tags/mood",
            "description": "Create endpoint to update existing journal entries, allowing edits to polished_content, tags, and mood fields only",
            "dependencies": [
              5
            ],
            "details": "Implement PUT /api/entries/:id. Zod schema: { polishedContent: string (optional), tags: string[] (optional), mood: string (optional) }. At least one field required. Query entry by id and userId (user isolation). Return 404 if not found/unauthorized. Update only provided fields. Set updated_at to current timestamp. Return 200 with updated entry. DO NOT allow editing rawContent, entryDate, type, source.",
            "status": "pending",
            "testStrategy": "Test updating each field individually and combined. Test with no fields provided (400). Test updating another user's entry (404). Verify rawContent/entryDate cannot be changed. Verify updated_at timestamp changes. Test with invalid data types (400).",
            "parentId": "undefined"
          },
          {
            "id": 9,
            "title": "Implement DELETE /api/entries/:id with soft delete and cascade",
            "description": "Create endpoint to soft delete journal entries, marking them as deleted in database and cascading to associated media",
            "dependencies": [
              5
            ],
            "details": "Implement DELETE /api/entries/:id. Query entry by id and userId (user isolation). Return 404 if not found/unauthorized. Soft delete: SET deleted_at = CURRENT_TIMESTAMP in entries table (add deleted_at column if not exists). Cascade: also set deleted_at on all related media records. Modify all GET queries to filter WHERE deleted_at IS NULL. Return 204 No Content on success. Consider adding UNDELETE endpoint for recovery.",
            "status": "pending",
            "testStrategy": "Test deleting valid entry returns 204. Verify entry no longer appears in GET /api/entries. Verify GET /api/entries/:id returns 404 after delete. Test deleting another user's entry (404). Verify associated media is also soft deleted. Test deleting already-deleted entry (404).",
            "parentId": "undefined"
          },
          {
            "id": 10,
            "title": "Ensure all operations filtered by userId from JWT",
            "description": "Implement and enforce user isolation across all endpoints, ensuring users can only access their own journal entries",
            "dependencies": [
              1,
              5,
              6,
              8,
              9
            ],
            "details": "Extract userId from JWT token in middleware (use Hono's context). Add userId to every database query WHERE clause: WHERE user_id = ? AND deleted_at IS NULL. Audit all endpoints (GET list, GET single, POST, PUT, DELETE) to ensure userId filtering. Add integration tests specifically for cross-user access attempts. Document user isolation guarantees in Glass spec. Consider adding audit logging for failed authorization attempts.",
            "status": "pending",
            "testStrategy": "Test each endpoint with authenticated user can only access own entries. Test attempting to access another user's entry by ID (should return 404, not 403 to prevent enumeration). Test unauthenticated requests (401). Verify JWT validation middleware runs before all handlers.",
            "parentId": "undefined"
          },
          {
            "id": 11,
            "title": "Create Glass spec for routes/entries.glass with isolation contract",
            "description": "Write Glass framework specification documenting the entries API contract, user isolation guarantees, and validation rules",
            "dependencies": [
              10
            ],
            "details": "Create `glass/routes/entries.glass` following GLASS.md format. Document: Intent (expose journal entry management to users), Contract (user isolation guarantee - users can only access own entries, input validation with Zod, pagination correctness, atomic operations), Dependencies (D1 database, JWT auth, AI service for polish), Failure Modes (invalid input returns 400, unauthorized access returns 404, DB errors return 500). Include example requests/responses. Document pagination algorithm, search behavior, soft delete semantics.",
            "status": "pending",
            "testStrategy": "Review Glass spec against implementation. Verify all contract guarantees are tested. Ensure spec documents all query parameters, request/response schemas, error codes. Validate spec follows GLASS.md conventions. Get peer review of spec completeness.",
            "parentId": "undefined"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 11,
        "expansionPrompt": "Break down entries API into: (1) implement GET /api/entries with pagination (page, limit params), (2) add filtering by date range (startDate, endDate), (3) add filtering by type and source, (4) implement full-text search functionality, (5) implement GET /api/entries/:id with media attachments, (6) implement POST /api/entries with Zod validation, (7) integrate async AI polish when polishWithAI=true, (8) implement PUT /api/entries/:id for editing polished content/tags/mood, (9) implement DELETE /api/entries/:id with soft delete and cascade, (10) ensure all operations filtered by userId from JWT, (11) create Glass spec for routes/entries.glass with isolation contract"
      },
      {
        "id": "9",
        "title": "Implement Twilio SMS/MMS inbound webhook with phone verification",
        "description": "Build Twilio webhook handler for receiving SMS/MMS messages, process text and media attachments, match to verified users by phone number, and create journal entries automatically.",
        "details": "Create `src/routes/api/webhooks.ts` with POST /api/webhooks/twilio endpoint.\n\nImplement Twilio webhook signature validation using X-Twilio-Signature header (CRITICAL for security).\n\nWebhook processing flow (from PRD section 8.1):\n1. Validate Twilio signature\n2. Extract From (phone number), Body (text), NumMedia, MediaUrl0-9, MediaContentType0-9\n3. Look up user by phone_number where phone_verified=1. If not found, send SMS: \"This number is not registered. Visit journalizer.com to set up.\"\n4. Process message:\n   - Text only: Create entry with raw_content=Body, entry_type='text', source='sms'\n   - Photo attached: Download from MediaUrl, upload to R2 via media service, create entry with entry_type='photo', attach media\n   - Audio attached: Download, upload to R2, send to transcription service, create entry with raw_content=transcript, entry_type='audio', attach media\n   - Video attached: Download, upload to R2, send to transcription service (audio track), create entry with raw_content=transcript, entry_type='video', attach media\n5. Send polished entry to AI service (background job)\n6. Respond to webhook with TwiML: \"Got it! Your entry has been saved. \"\n\nImplement phone verification in `src/routes/api/settings.ts`:\n- POST /api/settings/verify-phone - Generate 6-digit code, store in KV with 10-min TTL, send via Twilio SMS\n- POST /api/settings/confirm-phone - Validate code from KV, set phone_verified=1\n\nGlass specs:\n- `glass/webhooks/twilio.glass` - Intent: receive user journal entries via SMS; Contract: guarantees signature validation, user matching, media processing, confirmation delivery\n- `glass/settings/phone-verify.glass` - Intent: verify user phone ownership; Contract: guarantees code expiration, rate limiting, secure delivery",
        "testStrategy": "Use Twilio's webhook testing tool to send mock requests. Test signature validation with correct and incorrect signatures. Test all media types (text, photo, audio, video). Verify unregistered numbers receive error message. Test phone verification flow end-to-end. Test rate limiting on verification codes.",
        "priority": "high",
        "dependencies": [
          "5",
          "6",
          "7",
          "8"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Twilio webhook endpoint with POST /api/webhooks/twilio route",
            "description": "Set up the basic webhook endpoint structure in src/routes/api/webhooks.ts to receive Twilio SMS/MMS messages",
            "dependencies": [],
            "details": "Create src/routes/api/webhooks.ts file with POST /api/webhooks/twilio endpoint handler. Set up route registration in main router. Accept form-urlencoded webhook payload from Twilio. Return 200 OK response structure. This is the foundation for all webhook processing.",
            "status": "pending",
            "testStrategy": "Test endpoint responds to POST requests with 200 OK. Verify route is registered correctly. Use curl or Postman to send test payloads.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement X-Twilio-Signature validation for webhook security",
            "description": "Validate incoming webhook requests using Twilio signature validation to prevent unauthorized access (CRITICAL security feature)",
            "dependencies": [
              1
            ],
            "details": "Extract X-Twilio-Signature header from request. Compute HMAC-SHA1 signature using Twilio auth token and full request URL + payload. Compare computed signature with header value using constant-time comparison. Reject requests with invalid signatures with 403 Forbidden. Reference Twilio security docs for exact algorithm.",
            "status": "pending",
            "testStrategy": "Test with valid Twilio signatures (pass). Test with invalid/missing signatures (reject with 403). Use Twilio's webhook testing tool to send real signed requests. Verify constant-time comparison prevents timing attacks.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Parse Twilio webhook payload (From, Body, NumMedia, MediaUrl, MediaContentType)",
            "description": "Extract all relevant fields from the Twilio webhook form-urlencoded payload including phone number, message text, and media attachments",
            "dependencies": [
              2
            ],
            "details": "Parse form-urlencoded body to extract: From (sender phone number in E.164 format), Body (message text), NumMedia (count of attachments), MediaUrl0-9 (media URLs), MediaContentType0-9 (MIME types). Handle cases where NumMedia=0 (text-only). Validate phone number format. Log parsed data for debugging.",
            "status": "pending",
            "testStrategy": "Test parsing text-only messages (NumMedia=0). Test with 1-10 media attachments. Verify phone number extraction in E.164 format. Test with missing Body field. Validate all MediaUrl and MediaContentType fields are correctly indexed.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement user lookup by phone_number with phone_verified=1 check",
            "description": "Query D1 database to find user by phone number and verify their phone is verified before processing the message",
            "dependencies": [
              3
            ],
            "details": "Query users table: SELECT * FROM users WHERE phone_number = ? AND phone_verified = 1. Use prepared statement to prevent SQL injection. Handle case where no user found (return null). Handle case where user found but phone_verified=0 (treat as unregistered). Cache lookup result for current request processing.",
            "status": "pending",
            "testStrategy": "Test lookup with registered verified phone (success). Test with unregistered phone (null). Test with registered but unverified phone (null). Verify SQL injection protection. Test query performance with large user table.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Handle unregistered phone numbers with SMS error response",
            "description": "Send informative SMS reply to unregistered phone numbers directing them to register on the website",
            "dependencies": [
              4
            ],
            "details": "When user lookup returns null, use Twilio Messages API to send SMS: 'This number is not registered. Visit journalizer.com to set up.' Use Twilio REST API with account SID and auth token. Set From to Twilio phone number, To to sender's number, Body to error message. Log failed lookup attempts. Return TwiML empty response to webhook.",
            "status": "pending",
            "testStrategy": "Test with unregistered number receives SMS error. Verify SMS content matches spec. Test Twilio API error handling (rate limit, invalid number). Confirm webhook returns valid TwiML response.",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Handle text-only messages: create journal entry and queue for AI processing",
            "description": "Process SMS messages without media attachments by creating text journal entries and sending to AI service for polishing",
            "dependencies": [
              4
            ],
            "details": "When NumMedia=0, create entry in entries table: user_id, raw_content=Body, entry_type='text', source='sms', entry_date=now(), created_at=now(). Generate UUID for entry ID. Queue background job to AI service for polishing (use Cloudflare Queue or async task). Return entry ID for confirmation.",
            "status": "pending",
            "testStrategy": "Test creating text entry in database. Verify entry_type='text' and source='sms'. Test Body extraction handles empty messages. Verify AI queue job is created. Test Unicode/emoji handling in message text.",
            "parentId": "undefined"
          },
          {
            "id": 7,
            "title": "Handle photo MMS: download from Twilio, upload to R2, create entry",
            "description": "Process MMS messages with photo attachments by downloading media, storing in R2, and creating photo journal entries",
            "dependencies": [
              4
            ],
            "details": "When MediaContentType0 starts with 'image/', fetch MediaUrl0 with Twilio basic auth. Download image bytes. Generate unique filename (userId_timestamp_uuid.ext). Upload to R2 using media service POST /api/media/upload. Create entry: entry_type='photo', raw_content=Body (caption), source='sms'. Insert media record linking entry_id, media_url (R2 URL), media_type='photo'. Handle multiple images if NumMedia>1.",
            "status": "pending",
            "testStrategy": "Test downloading image from Twilio URL. Test R2 upload success. Verify media record created with correct URL. Test multiple photos in single MMS. Test image format support (JPEG, PNG, GIF). Test Twilio URL expiration handling.",
            "parentId": "undefined"
          },
          {
            "id": 8,
            "title": "Handle audio MMS: download, upload to R2, transcribe, create entry",
            "description": "Process MMS messages with audio attachments by downloading, storing, transcribing via transcription service, and creating audio entries",
            "dependencies": [
              4
            ],
            "details": "When MediaContentType0 starts with 'audio/', fetch MediaUrl0 and download audio file. Upload to R2 via media service. Send audio file URL to transcription service (OpenAI Whisper or similar). Wait for transcript response. Create entry: entry_type='audio', raw_content=transcript text, source='sms'. Link media record with audio file URL and transcription text. Queue AI polish job for transcript.",
            "status": "pending",
            "testStrategy": "Test audio download from Twilio. Test R2 upload for audio files. Test transcription API integration. Verify transcript stored in raw_content. Test audio formats (MP3, M4A, AMR). Test transcription error handling (silent audio, foreign language).",
            "parentId": "undefined"
          },
          {
            "id": 9,
            "title": "Handle video MMS: download, upload to R2, transcribe audio track, create entry",
            "description": "Process MMS messages with video attachments by downloading, storing, extracting and transcribing audio track, and creating video entries",
            "dependencies": [
              4
            ],
            "details": "When MediaContentType0 starts with 'video/', fetch MediaUrl0 and download video file. Upload to R2 via media service. Extract audio track from video (may need ffmpeg or transcription service handles this). Send audio to transcription service. Create entry: entry_type='video', raw_content=transcript, source='sms'. Link media record with video URL and transcription. Queue AI polish job.",
            "status": "pending",
            "testStrategy": "Test video download from Twilio. Test R2 upload for video files. Test audio extraction and transcription. Verify video formats (MP4, MOV). Test videos without audio track (silent). Test transcription service handles video input.",
            "parentId": "undefined"
          },
          {
            "id": 10,
            "title": "Queue background job to send polished entry to AI service",
            "description": "After creating journal entry, enqueue async job to AI service for content polishing and enhancement",
            "dependencies": [
              6,
              7,
              8,
              9
            ],
            "details": "After entry creation, enqueue job to Cloudflare Queue with payload: { entryId, userId, rawContent, entryType }. AI worker processes queue, calls OpenAI API for polishing, updates entries.polished_content field. Set job retry policy (3 attempts, exponential backoff). Log job creation. Return immediately without blocking webhook response.",
            "status": "pending",
            "testStrategy": "Test job enqueued successfully. Verify queue payload structure. Test AI worker processes job and updates polished_content. Test retry logic on AI API failure. Verify webhook responds quickly without waiting for AI.",
            "parentId": "undefined"
          },
          {
            "id": 11,
            "title": "Respond to webhook with TwiML confirmation message",
            "description": "Return TwiML response to Twilio webhook acknowledging successful message receipt and processing",
            "dependencies": [
              5,
              6,
              7,
              8,
              9
            ],
            "details": "Generate TwiML XML response: <?xml version=\"1.0\" encoding=\"UTF-8\"?><Response><Message>Got it! Your entry has been saved. </Message></Response>. Set Content-Type: text/xml. Return 200 OK status. This confirms to user their message was received. Twilio will send this SMS back to user.",
            "status": "pending",
            "testStrategy": "Test TwiML response format is valid XML. Verify Content-Type header is text/xml. Confirm user receives confirmation SMS from Twilio. Test emoji rendering in SMS response.",
            "parentId": "undefined"
          },
          {
            "id": 12,
            "title": "Implement POST /api/settings/verify-phone with 6-digit code generation",
            "description": "Create endpoint to initiate phone verification by generating verification code and storing in KV with TTL",
            "dependencies": [],
            "details": "Create src/routes/api/settings.ts. Implement POST /api/settings/verify-phone endpoint. Require authenticated user. Accept body: { phoneNumber: string (E.164 format) }. Validate phone format. Generate random 6-digit code (100000-999999). Store in KV: key='phone_verify:{phoneNumber}', value={ code, userId, attempts: 0 }, TTL=10 minutes. Rate limit: max 3 verification requests per phone per hour (check KV rate limit key).",
            "status": "pending",
            "testStrategy": "Test code generation produces 6 digits. Test KV storage with 10-min TTL. Test rate limiting blocks 4th request in hour. Test phone number validation rejects invalid formats. Verify authenticated user required.",
            "parentId": "undefined"
          },
          {
            "id": 13,
            "title": "Send verification code SMS via Twilio API",
            "description": "Use Twilio Messages API to send the 6-digit verification code to user's phone number",
            "dependencies": [
              12
            ],
            "details": "After generating code in verify-phone endpoint, call Twilio Messages API: POST https://api.twilio.com/2010-04-01/Accounts/{AccountSid}/Messages.json with body: To={phoneNumber}, From={TwilioPhoneNumber}, Body='Your Journalizer verification code is: {code}. Valid for 10 minutes.' Use HTTP basic auth with Twilio SID and token. Handle API errors (invalid number, rate limit). Return success response without exposing code.",
            "status": "pending",
            "testStrategy": "Test SMS delivery to real phone number. Verify message content includes code and expiration. Test Twilio API error handling. Test rate limit handling from Twilio side. Confirm code not leaked in API response.",
            "parentId": "undefined"
          },
          {
            "id": 14,
            "title": "Implement POST /api/settings/confirm-phone with code validation",
            "description": "Create endpoint to verify phone ownership by validating the 6-digit code submitted by user",
            "dependencies": [
              13
            ],
            "details": "Implement POST /api/settings/confirm-phone. Accept body: { phoneNumber, code: string }. Retrieve KV value for 'phone_verify:{phoneNumber}'. Verify code matches and userId matches current user. Increment attempts counter. If attempts >= 3, delete KV entry and return error. If code valid, update users table: SET phone_number={phoneNumber}, phone_verified=1 WHERE id={userId}. Delete KV entry. Return success.",
            "status": "pending",
            "testStrategy": "Test valid code confirms phone. Test invalid code rejected. Test 3 failed attempts locks verification. Test expired code (after 10 min) rejected. Test code for different user rejected. Verify phone_verified=1 set in database.",
            "parentId": "undefined"
          },
          {
            "id": 15,
            "title": "Create Glass specs for webhooks/twilio.glass and settings/phone-verify.glass",
            "description": "Document the webhook and phone verification flows in Glass framework format with intents, contracts, and guarantees",
            "dependencies": [
              11,
              14
            ],
            "details": "Create glass/webhooks/twilio.glass: Intent='receive user journal entries via SMS', Contract guarantees: (1) signature validation prevents unauthorized requests, (2) user matching requires phone_verified=1, (3) media processing handles all types (text/photo/audio/video), (4) confirmation delivery via TwiML. Create glass/settings/phone-verify.glass: Intent='verify user phone ownership', Contract guarantees: (1) code expiration after 10 minutes, (2) rate limiting 3 verifications per hour, (3) 3 attempt limit per code, (4) secure delivery via Twilio SMS. Document all edge cases and error handling.",
            "status": "pending",
            "testStrategy": "Review Glass specs for completeness against PRD requirements. Verify all contracts are testable. Ensure intents clearly describe system behavior. Validate guarantees cover security requirements (signature validation, rate limiting, TTL).",
            "parentId": "undefined"
          }
        ],
        "complexity": 9,
        "recommendedSubtasks": 15,
        "expansionPrompt": "Break down Twilio webhook into: (1) implement POST /api/webhooks/twilio endpoint, (2) implement X-Twilio-Signature validation (critical security), (3) parse Twilio webhook payload (From, Body, NumMedia, MediaUrl0-9), (4) look up user by phone_number with phone_verified=1, (5) handle unregistered number case with SMS response, (6) handle text-only messages - create entry and send to AI, (7) handle photo MMS - download from Twilio, upload to R2, create entry, (8) handle audio MMS - download, upload to R2, send to transcription, create entry with transcript, (9) handle video MMS - download, upload to R2, transcribe audio track, create entry, (10) send polished entry to AI service (background job), (11) respond with TwiML confirmation, (12) implement POST /api/settings/verify-phone with 6-digit code generation, (13) store code in KV with 10-min TTL, (14) send verification SMS via Twilio, (15) implement POST /api/settings/confirm-phone with code validation and rate limiting (3 attempts max)"
      },
      {
        "id": "10",
        "title": "Create user settings API for profile, voice preferences, and phone management",
        "description": "Build settings management API that allows users to configure their profile, AI voice style preferences, phone number verification, timezone, and export data.",
        "details": "Create `src/routes/api/settings.ts` with:\n\n- GET /api/settings - Return user settings: { displayName, email, avatarUrl, phoneNumber, phoneVerified, voiceStyle, voiceNotes, timezone, createdAt }\n- PUT /api/settings - Update settings. Body: { displayName?, voiceStyle?: 'natural'|'conversational'|'reflective'|'polished', voiceNotes?: string, timezone?: string }. Validate timezone against IANA database\n- POST /api/settings/verify-phone - Start phone verification. Body: { phoneNumber }. Validate E.164 format. Generate 6-digit code, store in KV: key=`phone-verify:{userId}`, value={ phoneNumber, code, attempts: 0 }, TTL=10min. Send via Twilio: \"Your Journalizer verification code is: {code}\"\n- POST /api/settings/confirm-phone - Confirm verification. Body: { code }. Check KV, validate code, increment attempts (max 3), update users.phone_number and phone_verified=1, delete KV entry\n- GET /api/settings/export - (Handled in export route) Return user data JSON with all entries and media references\n\nImplement rate limiting: 3 verification SMS per hour per user using KV counter.\n\nGlass spec:\n- `glass/routes/settings.glass` - Intent: user preference management; Contract: guarantees phone verification security, timezone validation, rate limiting on verification, data export completeness",
        "testStrategy": "Test updating all settings fields. Verify voice preferences affect AI polish output. Test phone verification flow including incorrect codes and rate limiting. Test timezone validation with valid/invalid values. Verify export includes all user data.",
        "priority": "medium",
        "dependencies": [
          "8",
          "9"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement GET /api/settings endpoint to fetch user settings",
            "description": "Create the GET endpoint that retrieves current user settings including profile data, voice preferences, phone verification status, and timezone from D1 database.",
            "dependencies": [],
            "details": "Query the users table in D1 to fetch displayName, email, avatarUrl, phoneNumber, phoneVerified, voiceStyle, voiceNotes, timezone, and createdAt fields. Ensure proper authentication middleware is applied. Return JSON response with all settings. Handle cases where user doesn't exist or fields are null.",
            "status": "pending",
            "testStrategy": "Test with authenticated user to verify all fields are returned correctly. Test with new user to verify default values. Test without authentication to verify 401 response.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Create Zod validation schemas for settings update requests",
            "description": "Define comprehensive Zod schemas to validate PUT /api/settings request body including displayName, voiceStyle enum, voiceNotes length limits, and timezone format.",
            "dependencies": [],
            "details": "Create Zod schema with: displayName (optional string, max 100 chars), voiceStyle (optional enum: 'natural'|'conversational'|'reflective'|'polished'), voiceNotes (optional string, max 500 chars), timezone (optional string for IANA validation). Ensure proper error messages for validation failures.",
            "status": "pending",
            "testStrategy": "Test schema with valid inputs for each field. Test with invalid enum values, oversized strings, and malformed data. Verify error messages are descriptive.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement IANA timezone validation logic",
            "description": "Add timezone validation against the IANA timezone database to ensure only valid timezone identifiers are accepted in settings updates.",
            "dependencies": [
              2
            ],
            "details": "Use a library like 'spacetime' or validate against Intl.supportedValuesOf('timeZone') to check if provided timezone is valid IANA identifier (e.g., 'America/New_York'). Integrate into Zod schema refinement or custom validator. Return clear error message for invalid timezones.",
            "status": "pending",
            "testStrategy": "Test with valid timezones (America/New_York, Europe/London, Asia/Tokyo). Test with invalid values (EST, GMT+5, random strings). Verify validation errors are returned.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement PUT /api/settings endpoint with validation and D1 update",
            "description": "Create the PUT endpoint that validates incoming settings data using Zod schemas and updates the users table in D1 database with new settings values.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Parse request body with Zod schema from subtask 2. Validate timezone with logic from subtask 3. Execute D1 UPDATE query to modify displayName, voiceStyle, voiceNotes, and timezone fields for authenticated user. Return updated settings object. Handle database errors and validation failures with appropriate HTTP status codes.",
            "status": "pending",
            "testStrategy": "Test updating each field individually and in combination. Verify database persistence. Test with invalid data to confirm validation errors. Test concurrent updates to same user settings.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Integrate phone verification endpoints from task 9",
            "description": "Add POST /api/settings/verify-phone and POST /api/settings/confirm-phone endpoints by integrating the phone verification logic from task 9 into the settings route.",
            "dependencies": [
              4
            ],
            "details": "Import or reference phone verification handlers from task 9 implementation. Mount verify-phone endpoint (validates E.164 format, generates 6-digit code, stores in KV with TTL=10min, sends Twilio SMS). Mount confirm-phone endpoint (validates code from KV, checks attempts <= 3, updates D1 users table phone_number and phone_verified=1, deletes KV entry). Ensure proper error handling.",
            "status": "pending",
            "testStrategy": "Test complete phone verification flow from verify to confirm. Test with invalid phone formats. Test with wrong codes and max attempts. Verify KV TTL expiration. Confirm D1 updates persist.",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Implement rate limiting for phone verification using KV counters",
            "description": "Add rate limiting logic to restrict users to 3 phone verification SMS messages per hour using Cloudflare KV as a counter store.",
            "dependencies": [
              5
            ],
            "details": "On POST /api/settings/verify-phone, check KV for key `rate-limit:phone-verify:{userId}`. If exists and count >= 3, return 429 Too Many Requests. Otherwise, increment counter with TTL=1 hour (3600 seconds). Use atomic KV operations if available. Return clear error message indicating remaining time until reset.",
            "status": "pending",
            "testStrategy": "Test sending 3 verification requests within an hour to hit limit. Test 4th request returns 429. Test that counter resets after 1 hour. Verify different users have separate rate limits.",
            "parentId": "undefined"
          },
          {
            "id": 7,
            "title": "Add voiceStyle enum validation and voiceNotes length constraints",
            "description": "Ensure strict validation of voiceStyle field against allowed enum values and enforce character limits on voiceNotes field with descriptive error messages.",
            "dependencies": [
              2
            ],
            "details": "In Zod schema, define voiceStyle as z.enum(['natural', 'conversational', 'reflective', 'polished']) with custom error message. Define voiceNotes as z.string().max(500) or similar appropriate limit with helpful error. Ensure validation occurs before database update in PUT endpoint.",
            "status": "pending",
            "testStrategy": "Test with each valid voiceStyle value. Test with invalid enum values (e.g., 'casual', 'formal'). Test voiceNotes at boundary (exactly limit, over limit). Verify error messages are clear.",
            "parentId": "undefined"
          },
          {
            "id": 8,
            "title": "Create Glass specification for settings route contracts",
            "description": "Write glass/routes/settings.glass defining the intent, contracts, validation guarantees, and security constraints for the settings management API.",
            "dependencies": [
              1,
              4,
              6,
              7
            ],
            "details": "Create settings.glass file documenting: Intent (user preference management), Contract (phone verification security with rate limiting, timezone IANA validation, voiceStyle enum enforcement, voiceNotes length limits, data export completeness), Validation contracts (E.164 phone format, 6-digit code format, max 3 verification attempts, 3 SMS per hour rate limit), Security (authenticated access only, user can only modify own settings). Follow Glass Framework format from GLASS.md.",
            "status": "pending",
            "testStrategy": "Review Glass spec against implementation to ensure all contracts are met. Verify all validation rules are documented. Confirm security constraints match middleware implementation.",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 8,
        "expansionPrompt": "Break down settings API into: (1) implement GET /api/settings to return user settings from D1, (2) implement PUT /api/settings with Zod validation, (3) add timezone validation against IANA database, (4) validate voiceStyle enum (natural/conversational/reflective/polished), (5) validate voiceNotes string length limits, (6) integrate with phone verification endpoints from task 9, (7) implement rate limiting on verify-phone (3 per hour using KV counter), (8) create Glass spec for routes/settings.glass with validation contracts"
      },
      {
        "id": "11",
        "title": "Implement reminder configuration API and storage",
        "description": "Build API for users to configure journal reminders (daily, weekly, monthly, smart nudge) with timezone-aware scheduling and active/inactive state management.",
        "details": "Create `src/routes/api/reminders.ts`:\n\n- GET /api/reminders - List all reminders for user\n- POST /api/reminders - Create reminder. Body: { reminderType: 'daily'|'weekly'|'monthly'|'smart', timeOfDay: 'HH:MM', dayOfWeek?: 0-6, dayOfMonth?: 1-28, smartThreshold?: number (days), isActive: boolean }. Validate: timeOfDay is valid time, dayOfWeek 0-6 for weekly, dayOfMonth 1-28 for monthly, smartThreshold 1-14 for smart\n- PUT /api/reminders/:id - Update reminder settings\n- DELETE /api/reminders/:id - Delete reminder\n\nStore in reminders table. Multiple reminders per user allowed (e.g., daily + smart).\n\nFor daily: fires every day at timeOfDay in user's timezone\nFor weekly: fires every week on dayOfWeek at timeOfDay\nFor monthly: fires every month on dayOfMonth at timeOfDay\nFor smart: fires only if (today - last_entry_date) >= smartThreshold\n\nGlass spec:\n- `glass/routes/reminders.glass` - Intent: configurable journal prompts; Contract: guarantees timezone handling, validation of time/day fields, user isolation, multiple reminders support",
        "testStrategy": "Test creating all reminder types with valid/invalid parameters. Verify timezone conversion logic. Test multiple reminders per user. Test updating active/inactive state. Verify validation errors for out-of-range values.",
        "priority": "medium",
        "dependencies": [
          "10"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement GET /api/reminders endpoint to list user reminders",
            "description": "Create the GET /api/reminders route to retrieve all reminders for the authenticated user from the reminders table.",
            "dependencies": [],
            "details": "In src/routes/api/reminders.ts, create GET endpoint that: (1) authenticates user via JWT middleware, (2) queries reminders table filtering by user_id, (3) returns array of reminder objects with all fields (id, user_id, reminderType, timeOfDay, dayOfWeek, dayOfMonth, smartThreshold, isActive, created_at, updated_at), (4) returns 200 with empty array if no reminders exist, (5) returns 401 if not authenticated.",
            "status": "pending",
            "testStrategy": "Test authenticated request returns user's reminders. Test empty array for new user. Test 401 for unauthenticated request. Verify only user's own reminders are returned (user isolation).",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Create Zod validation schema for reminder creation",
            "description": "Define comprehensive Zod schema for POST /api/reminders request body with type-specific conditional validation.",
            "dependencies": [],
            "details": "Create Zod schema that validates: (1) reminderType as enum ('daily', 'weekly', 'monthly', 'smart'), (2) timeOfDay as string matching HH:MM format (00:00-23:59), (3) dayOfWeek as optional number 0-6 (required for weekly), (4) dayOfMonth as optional number 1-28 (required for monthly), (5) smartThreshold as optional number 1-14 (required for smart), (6) isActive as boolean. Use Zod refinements to enforce conditional requirements based on reminderType.",
            "status": "pending",
            "testStrategy": "Test schema accepts valid inputs for all reminder types. Test schema rejects invalid reminderType values. Test timeOfDay validation rejects malformed times. Test conditional field validation for each type.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement reminderType enum validation",
            "description": "Validate that reminderType is one of the four allowed values: daily, weekly, monthly, or smart.",
            "dependencies": [
              2
            ],
            "details": "Within the Zod schema created in subtask 2, use z.enum(['daily', 'weekly', 'monthly', 'smart']) to strictly validate reminderType. Ensure validation error messages clearly indicate allowed values. This validation is critical for downstream scheduling logic.",
            "status": "pending",
            "testStrategy": "Test that only 'daily', 'weekly', 'monthly', 'smart' are accepted. Test invalid values like 'hourly', 'yearly', empty string return validation errors with helpful messages.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement timeOfDay format validation (HH:MM)",
            "description": "Validate that timeOfDay follows HH:MM 24-hour format with valid hour (00-23) and minute (00-59) values.",
            "dependencies": [
              2
            ],
            "details": "In the Zod schema, create custom validation for timeOfDay string using regex pattern /^([01]\\d|2[0-3]):([0-5]\\d)$/ to match HH:MM format. Additionally validate that parsed hours are 0-23 and minutes are 0-59. Return clear error message if format is invalid (e.g., '25:00', '12:60', '1:30' without leading zero).",
            "status": "pending",
            "testStrategy": "Test valid times: '00:00', '12:30', '23:59'. Test invalid formats: '24:00', '12:60', '1:30', 'abc', '12:5'. Verify error messages are descriptive.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement dayOfWeek validation (0-6) for weekly reminders",
            "description": "Validate that dayOfWeek is an integer from 0 (Sunday) to 6 (Saturday) when reminderType is 'weekly'.",
            "dependencies": [
              2,
              3
            ],
            "details": "Add Zod refinement to schema: when reminderType === 'weekly', dayOfWeek must be present and be an integer between 0 and 6 inclusive. Use z.number().int().min(0).max(6) with conditional logic. Return error if weekly reminder lacks dayOfWeek or value is out of range.",
            "status": "pending",
            "testStrategy": "Test weekly reminder with valid dayOfWeek (0, 3, 6). Test weekly reminder without dayOfWeek returns error. Test dayOfWeek = -1 or 7 returns validation error. Test dayOfWeek ignored for non-weekly types.",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Implement dayOfMonth validation (1-28) for monthly reminders",
            "description": "Validate that dayOfMonth is an integer from 1 to 28 when reminderType is 'monthly'.",
            "dependencies": [
              2,
              3
            ],
            "details": "Add Zod refinement: when reminderType === 'monthly', dayOfMonth must be present and be an integer between 1 and 28 inclusive (limited to 28 to avoid issues with February). Use z.number().int().min(1).max(28) with conditional logic. Return error if monthly reminder lacks dayOfMonth or value is out of range.",
            "status": "pending",
            "testStrategy": "Test monthly reminder with valid dayOfMonth (1, 15, 28). Test monthly reminder without dayOfMonth returns error. Test dayOfMonth = 0, 29, 31 returns validation error. Test dayOfMonth ignored for non-monthly types.",
            "parentId": "undefined"
          },
          {
            "id": 7,
            "title": "Implement smartThreshold validation (1-14) for smart reminders",
            "description": "Validate that smartThreshold is an integer from 1 to 14 days when reminderType is 'smart'.",
            "dependencies": [
              2,
              3
            ],
            "details": "Add Zod refinement: when reminderType === 'smart', smartThreshold must be present and be an integer between 1 and 14 inclusive (representing days since last entry). Use z.number().int().min(1).max(14) with conditional logic. Return error if smart reminder lacks smartThreshold or value is out of range.",
            "status": "pending",
            "testStrategy": "Test smart reminder with valid smartThreshold (1, 7, 14). Test smart reminder without smartThreshold returns error. Test smartThreshold = 0, 15, 100 returns validation error. Test smartThreshold ignored for non-smart types.",
            "parentId": "undefined"
          },
          {
            "id": 8,
            "title": "Implement POST /api/reminders endpoint with complete validation",
            "description": "Create POST endpoint to create new reminders using validated Zod schema and insert into reminders table.",
            "dependencies": [
              2,
              3,
              4,
              5,
              6,
              7
            ],
            "details": "In src/routes/api/reminders.ts, create POST endpoint that: (1) authenticates user, (2) validates request body using complete Zod schema from subtasks 2-7, (3) inserts reminder into reminders table with user_id from JWT, (4) allows multiple reminders per user (no uniqueness constraint), (5) returns 201 with created reminder object including generated id, (6) returns 400 with validation errors if schema validation fails, (7) returns 401 if not authenticated.",
            "status": "pending",
            "testStrategy": "Test creating all four reminder types with valid data. Test multiple reminders per user are allowed. Test validation errors return 400 with clear messages. Test 401 for unauthenticated requests. Verify created reminder is returned with id.",
            "parentId": "undefined"
          },
          {
            "id": 9,
            "title": "Implement PUT /api/reminders/:id and DELETE /api/reminders/:id endpoints with Glass spec",
            "description": "Create PUT and DELETE endpoints for updating and deleting reminders, then document in Glass specification file.",
            "dependencies": [
              1,
              8
            ],
            "details": "In src/routes/api/reminders.ts: (1) PUT /api/reminders/:id - authenticate user, validate same Zod schema as POST, verify reminder belongs to user (user_id match), update all fields, return 200 with updated reminder or 404 if not found/not owned. (2) DELETE /api/reminders/:id - authenticate user, verify ownership, delete reminder, return 204 on success or 404 if not found/not owned. Create glass/routes/reminders.glass with Intent: 'configurable journal prompts', Contract: guarantees timezone handling, validation of time/day fields, user isolation (user can only access own reminders), multiple reminders support, and complete validation rules for all four reminder types.",
            "status": "pending",
            "testStrategy": "Test PUT updates all fields correctly. Test PUT with invalid data returns 400. Test PUT/DELETE with non-existent id returns 404. Test users cannot update/delete other users' reminders (403/404). Test DELETE returns 204 on success. Verify Glass spec documents all validation contracts.",
            "parentId": "undefined"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 9,
        "expansionPrompt": "Break down reminders API into: (1) implement GET /api/reminders to list user reminders, (2) implement POST /api/reminders with Zod validation, (3) validate reminderType enum (daily/weekly/monthly/smart), (4) validate timeOfDay format (HH:MM), (5) validate dayOfWeek (0-6) for weekly reminders, (6) validate dayOfMonth (1-28) for monthly reminders, (7) validate smartThreshold (1-14) for smart reminders, (8) implement PUT /api/reminders/:id and DELETE /api/reminders/:id, (9) create Glass spec for routes/reminders.glass with validation contracts"
      },
      {
        "id": "12",
        "title": "Build Cron Trigger worker for processing scheduled reminders",
        "description": "Implement scheduled worker using Cloudflare Cron Triggers that runs every 15 minutes to process due reminders, handles timezone conversion, checks smart nudge conditions, and sends SMS via Twilio.",
        "details": "Create `src/services/reminders.ts` with cron handler.\n\nIn wrangler.toml, add:\n```toml\n[triggers]\ncrons = [\"*/15 * * * *\"]  # Every 15 minutes\n```\n\nCron logic:\n```typescript\nexport async function handleCron(env: Env) {\n  const now = new Date();\n  const activeReminders = await getAllActiveReminders(env.DB);\n  \n  for (const reminder of activeReminders) {\n    const user = await getUserById(reminder.userId, env.DB);\n    const userTime = convertToTimezone(now, user.timezone);\n    \n    if (shouldFireReminder(reminder, userTime, user)) {\n      const message = selectReminderMessage(reminder.reminderType);\n      await sendSMS(user.phoneNumber, message, env);\n      await updateLastSentAt(reminder.id, now, env.DB);\n    }\n  }\n}\n```\n\nSmart nudge logic: Query entries table for user's most recent entry, calculate days since, compare to smartThreshold.\n\nReminder messages rotate through variations (PRD section 8.4):\n- \"Hey! What happened today? Just reply to this message \"\n- \"Quick check-in: How's your day going? Reply with anything.\"\n- \"It's been {X} days since your last entry. No pressure, but we're here when you're ready!\"\n\nGlass spec:\n- `glass/services/reminders.glass` - Intent: automated journal prompts; Contract: guarantees timezone-accurate delivery, smart threshold calculation, message delivery confirmation, no duplicate sends",
        "testStrategy": "Test cron trigger locally with `wrangler dev`. Mock current time and test all reminder types fire at correct times. Test timezone conversion for users in different zones. Test smart nudge logic with various entry gaps. Verify Twilio SMS delivery. Test duplicate prevention (last_sent_at check).",
        "priority": "medium",
        "dependencies": [
          "11"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Configure Cloudflare Cron Trigger in wrangler.toml",
            "description": "Add cron trigger configuration to wrangler.toml to execute the reminder worker every 15 minutes using the schedule pattern */15 * * * *",
            "dependencies": [],
            "details": "Edit wrangler.toml and add a [triggers] section with crons array containing the pattern \"*/15 * * * *\". This configures the Worker to run every 15 minutes. Verify the syntax matches Cloudflare's cron trigger format and ensure it's properly positioned in the configuration file.",
            "status": "pending",
            "testStrategy": "Verify wrangler.toml syntax with `wrangler deploy --dry-run`. Test locally with `wrangler dev` to ensure cron trigger is recognized. Check Cloudflare dashboard after deployment to confirm cron schedule appears correctly.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Create reminders service file and handleCron entry point",
            "description": "Create src/services/reminders.ts with the main handleCron function that serves as the entry point for the cron trigger execution",
            "dependencies": [
              1
            ],
            "details": "Create the file structure for src/services/reminders.ts. Implement the handleCron(env: Env) function skeleton that will be called by the cron trigger. Set up proper TypeScript typing for the Env parameter including D1, KV, and environment variable bindings. Add the scheduled handler export in the main worker file to route cron events to handleCron.",
            "status": "pending",
            "testStrategy": "Verify TypeScript compilation succeeds. Test that handleCron is called when cron trigger fires using `wrangler dev` with manual trigger. Add console logging to confirm function execution.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement getAllActiveReminders database query function",
            "description": "Create database query function to fetch all active reminders from the reminders table that need to be evaluated for sending",
            "dependencies": [
              2
            ],
            "details": "Implement getAllActiveReminders(db: D1Database) function that queries the reminders table for all reminders where is_active = true. Return reminder records with userId, reminderType, timeOfDay, dayOfWeek, dayOfMonth, smartThreshold, and last_sent_at fields. Optimize query for performance since it runs every 15 minutes.",
            "status": "pending",
            "testStrategy": "Test query returns only active reminders. Verify all necessary fields are included in the result set. Test with empty database, single reminder, and multiple reminders. Measure query performance to ensure it completes quickly.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement timezone conversion utility function",
            "description": "Create convertToTimezone function that converts UTC server time to user's local timezone using their timezone setting from the users table",
            "dependencies": [
              2
            ],
            "details": "Implement convertToTimezone(utcDate: Date, timezone: string): Date function using Intl.DateTimeFormat or date-fns-tz library. Handle IANA timezone identifiers (e.g., 'America/Los_Angeles'). Extract hour and minute components in user's local time for comparison with reminder timeOfDay settings. Include proper error handling for invalid timezone strings.",
            "status": "pending",
            "testStrategy": "Test conversion with multiple timezones (US/Pacific, US/Eastern, Europe/London, Asia/Tokyo). Test edge cases like DST transitions. Verify hour and minute extraction is accurate. Test invalid timezone handling returns meaningful error.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement shouldFireReminder logic for daily reminders",
            "description": "Create logic to determine if a daily reminder should fire by comparing current user local time to configured timeOfDay",
            "dependencies": [
              3,
              4
            ],
            "details": "Implement shouldFireReminder function that takes reminder config, user local time, and last_sent_at timestamp. For daily reminders, check if current time hour:minute matches timeOfDay within the 15-minute window. Ensure reminder hasn't been sent already today by checking last_sent_at date. Return boolean indicating whether to send.",
            "status": "pending",
            "testStrategy": "Test reminder fires when current time matches timeOfDay. Test reminder doesn't fire if already sent today (last_sent_at is same day). Test 15-minute window tolerance (e.g., 09:00 reminder fires between 09:00-09:14). Test doesn't fire outside the window.",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Implement weekly reminder matching logic",
            "description": "Add weekly reminder logic that checks both day of week and time of day before firing",
            "dependencies": [
              5
            ],
            "details": "Extend shouldFireReminder to handle reminderType='weekly'. Check if current day of week (0-6, Sunday=0) matches reminder.dayOfWeek. Also verify timeOfDay matches within 15-minute window. Check last_sent_at to ensure reminder hasn't fired this week on this day. Return true only if all conditions match.",
            "status": "pending",
            "testStrategy": "Test reminder fires on correct day of week at correct time. Test doesn't fire on wrong day even if time matches. Test doesn't fire twice on same day. Test week boundary transitions (Saturday to Sunday).",
            "parentId": "undefined"
          },
          {
            "id": 7,
            "title": "Implement monthly reminder matching logic",
            "description": "Add monthly reminder logic that checks day of month and time of day before firing",
            "dependencies": [
              6
            ],
            "details": "Extend shouldFireReminder to handle reminderType='monthly'. Check if current day of month (1-31) matches reminder.dayOfMonth. Also verify timeOfDay matches within 15-minute window. Check last_sent_at to ensure reminder hasn't fired this month on this day. Handle months with fewer days (e.g., dayOfMonth=31 won't fire in February).",
            "status": "pending",
            "testStrategy": "Test reminder fires on correct day of month at correct time. Test doesn't fire on wrong day. Test doesn't fire twice in same month. Test edge cases: February (28/29 days), 30-day months, 31-day months.",
            "parentId": "undefined"
          },
          {
            "id": 8,
            "title": "Implement smart nudge logic with entry gap calculation",
            "description": "Create smart nudge logic that queries entries table to calculate days since last entry and compares to smartThreshold",
            "dependencies": [
              3,
              4
            ],
            "details": "Implement getLastEntryDate(userId, db) that queries entries table for user's most recent entry ordered by created_at DESC. Calculate daysSinceLastEntry = Math.floor((now - lastEntryDate) / (1000*60*60*24)). In shouldFireReminder for reminderType='smart', return true if daysSinceLastEntry >= smartThreshold and last_sent_at is not today. Handle case where user has no entries (send reminder if smartThreshold days passed since user creation).",
            "status": "pending",
            "testStrategy": "Test smart nudge fires when days since last entry exceeds threshold. Test doesn't fire if recent entry exists. Test doesn't fire multiple times same day. Test handles new users with no entries. Test various thresholds (1, 3, 7, 14 days).",
            "parentId": "undefined"
          },
          {
            "id": 9,
            "title": "Implement reminder message rotation system",
            "description": "Create selectReminderMessage function that rotates through 3-5 message variations based on reminder type and context",
            "dependencies": [],
            "details": "Implement selectReminderMessage(reminderType, daysSinceLastEntry?) that returns one of 3-5 message variations. Standard messages: 'Hey! What happened today? Just reply to this message ', 'Quick check-in: How's your day going? Reply with anything.'. Smart nudge variation: 'It's been {X} days since your last entry. No pressure, but we're here when you're ready!'. Use random selection or round-robin based on reminder ID to distribute evenly.",
            "status": "pending",
            "testStrategy": "Test all message variations are returned across multiple calls. Test smart nudge message includes correct day count. Test message selection is deterministic per reminder (same reminder gets consistent rotation). Verify messages match PRD section 8.4 exactly.",
            "parentId": "undefined"
          },
          {
            "id": 10,
            "title": "Integrate SMS service to send reminder messages",
            "description": "Call Twilio SMS API to send the selected reminder message to the user's verified phone number",
            "dependencies": [
              9
            ],
            "details": "Implement sendSMS(phoneNumber, message, env) function that uses Twilio API credentials from env (TWILIO_ACCOUNT_SID, TWILIO_AUTH_TOKEN, TWILIO_PHONE_NUMBER). Make HTTP POST to Twilio API to send SMS. Handle Twilio errors (invalid number, delivery failure) gracefully with logging. Return success/failure status. Ensure phone number is in E.164 format.",
            "status": "pending",
            "testStrategy": "Test SMS sends successfully to verified phone number. Test error handling for invalid numbers. Test Twilio API authentication. Test rate limiting (Twilio has sending limits). Mock Twilio API in tests to avoid actual SMS sends.",
            "parentId": "undefined"
          },
          {
            "id": 11,
            "title": "Update last_sent_at timestamp after successful SMS delivery",
            "description": "After successfully sending a reminder SMS, update the reminder's last_sent_at field in the database to prevent duplicate sends",
            "dependencies": [
              10
            ],
            "details": "Implement updateLastSentAt(reminderId, timestamp, db) function that executes UPDATE query on reminders table: SET last_sent_at = ? WHERE id = ?. Call this function immediately after successful sendSMS call. Use current UTC timestamp. This prevents the same reminder from firing again within the 15-minute cron window or same day.",
            "status": "pending",
            "testStrategy": "Test last_sent_at updates after SMS send. Test subsequent cron runs don't send duplicate reminders. Test update fails gracefully if database error occurs. Verify timestamp is stored in correct format (ISO 8601 UTC).",
            "parentId": "undefined"
          },
          {
            "id": 12,
            "title": "Create Glass specification for services/reminders.glass",
            "description": "Document the reminders service in Glass framework format with intent, contract, and guarantees for timezone-accurate delivery and duplicate prevention",
            "dependencies": [
              11
            ],
            "details": "Create glass/services/reminders.glass file following Glass Framework methodology. Document Intent: automated journal prompts via SMS on configurable schedules. Contract: guarantees timezone-accurate delivery (converts UTC to user timezone), smart threshold calculation (queries entries for gap analysis), message delivery confirmation (Twilio response), no duplicate sends within same day (last_sent_at tracking). Include function signatures for handleCron, shouldFireReminder, convertToTimezone, sendSMS. Document error handling approach.",
            "status": "pending",
            "testStrategy": "Verify Glass file follows format specified in GLASS.md. Ensure all public functions are documented with intent and contract. Review that guarantees match implementation (timezone accuracy, duplicate prevention, delivery confirmation).",
            "parentId": "undefined"
          }
        ],
        "complexity": 8,
        "recommendedSubtasks": 12,
        "expansionPrompt": "Break down cron worker into: (1) configure Cloudflare Cron Trigger in wrangler.toml (*/15 * * * *), (2) implement handleCron function to query active reminders, (3) implement timezone conversion logic using user's timezone setting, (4) implement shouldFireReminder logic for daily reminders, (5) implement weekly reminder logic with day matching, (6) implement monthly reminder logic with day-of-month matching, (7) implement smart nudge logic - query last entry date and compare to threshold, (8) implement reminder message rotation system (3-5 variations), (9) integrate with SMS service to send reminders, (10) update last_sent_at in reminders table, (11) implement duplicate prevention logic, (12) create Glass spec for services/reminders.glass with timezone-accuracy contract"
      },
      {
        "id": "13",
        "title": "Build outbound SMS service using Twilio Programmable Messaging",
        "description": "Create reusable SMS sending service for reminders, confirmations, and verification codes using Twilio's Messaging API with error handling and delivery tracking.",
        "details": "Create `src/services/sms.ts` with functions:\n\n```typescript\nasync function sendSMS(to: string, body: string, env: Env): Promise<SendResult>\n```\n\nUse Twilio REST API (not SDK, to avoid runtime issues with Workers):\n- POST to `https://api.twilio.com/2010-04-01/Accounts/{ACCOUNT_SID}/Messages.json`\n- Auth: Basic auth with ACCOUNT_SID and AUTH_TOKEN\n- Body: From={TWILIO_PHONE_NUMBER}, To={to}, Body={body}\n\nValidate E.164 phone format. Log all sends to processing_log. Handle Twilio errors:\n- 21211 (invalid To number): throw validation error\n- 21614 (unverified number in trial): throw trial limit error\n- Rate limits: implement exponential backoff\n\nSupport message templates:\n- verificationCode(code: string): \"Your Journalizer verification code is: {code}\"\n- entryConfirmation(): \"Got it! Your entry has been saved. \"\n- reminder(type: string): Select from rotation\n\nGlass spec:\n- `glass/services/sms.glass` - Intent: reliable SMS delivery; Contract: guarantees E.164 validation, error handling, delivery tracking, no PII in logs",
        "testStrategy": "Test sending to valid/invalid numbers. Verify Twilio API authentication. Test error handling for all Twilio error codes. Verify rate limiting and backoff. Test message templates. Confirm delivery with Twilio dashboard. Test with international numbers.",
        "priority": "medium",
        "dependencies": [
          "12"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement sendSMS function using Twilio REST API",
            "description": "Create the core SMS sending function that makes HTTP POST requests to Twilio's REST API endpoint without using the SDK to avoid Cloudflare Workers runtime issues.",
            "dependencies": [],
            "details": "Create `src/services/sms.ts` with the `sendSMS(to: string, body: string, env: Env): Promise<SendResult>` function. Implement POST request to `https://api.twilio.com/2010-04-01/Accounts/{ACCOUNT_SID}/Messages.json` using fetch API. Structure request body with URL-encoded parameters: From, To, and Body. Return SendResult containing message SID, status, and any error information.",
            "status": "pending",
            "testStrategy": "Test with mock Twilio API responses. Verify correct URL construction, request headers, and body formatting. Test successful message send returns expected SendResult structure.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Set up Basic Authentication with Twilio credentials",
            "description": "Implement Basic Auth header construction using TWILIO_ACCOUNT_SID and TWILIO_AUTH_TOKEN from environment variables.",
            "dependencies": [
              1
            ],
            "details": "Extract TWILIO_ACCOUNT_SID and TWILIO_AUTH_TOKEN from the Env object. Create Basic Auth header by base64 encoding 'ACCOUNT_SID:AUTH_TOKEN'. Add Authorization header to all Twilio API requests. Include Content-Type: application/x-www-form-urlencoded header.",
            "status": "pending",
            "testStrategy": "Verify Authorization header is correctly formatted with base64-encoded credentials. Test that requests fail with invalid credentials. Confirm successful authentication with Twilio API.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement E.164 phone number validation",
            "description": "Add phone number validation to ensure all recipient numbers conform to E.164 international format before sending SMS.",
            "dependencies": [
              1
            ],
            "details": "Create validation function that checks phone numbers match E.164 format (e.g., +1234567890). Validate that number starts with '+', followed by country code and subscriber number. Reject numbers missing '+' prefix or containing invalid characters. Throw descriptive validation errors for malformed numbers before making Twilio API call.",
            "status": "pending",
            "testStrategy": "Test validation with valid E.164 numbers (+14155551234, +447911123456). Test rejection of invalid formats (missing +, letters, too short/long). Verify international number formats are accepted.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Handle Twilio error codes and implement error mapping",
            "description": "Parse Twilio API error responses and map specific error codes (21211, 21614) to meaningful application errors with appropriate handling.",
            "dependencies": [
              2
            ],
            "details": "Parse JSON error responses from Twilio API. Handle error code 21211 (invalid To number) by throwing a validation error with helpful message. Handle error code 21614 (unverified number in trial account) by throwing trial limitation error. Map other common Twilio errors to appropriate error types. Include original Twilio error details in logs for debugging.",
            "status": "pending",
            "testStrategy": "Mock Twilio error responses for codes 21211 and 21614. Verify correct error types are thrown. Test that error messages are user-friendly. Confirm error details are logged but not exposed to end users.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement exponential backoff for rate limiting",
            "description": "Add retry logic with exponential backoff to handle Twilio rate limit errors gracefully and ensure reliable message delivery.",
            "dependencies": [
              4
            ],
            "details": "Detect rate limit errors from Twilio API (HTTP 429 or error code 20429). Implement exponential backoff: first retry after 1s, then 2s, 4s, 8s up to maximum 3-5 retries. Include jitter to prevent thundering herd. Respect Retry-After header if provided by Twilio. Throw final error if all retries exhausted.",
            "status": "pending",
            "testStrategy": "Mock rate limit responses from Twilio. Verify retry delays follow exponential pattern. Test that function eventually succeeds after rate limit clears. Confirm maximum retry limit is respected.",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Log SMS sends to processing_log without PII",
            "description": "Record all SMS sending attempts in the processing_log table for auditing and troubleshooting while ensuring no personally identifiable information is logged.",
            "dependencies": [
              1
            ],
            "details": "After each sendSMS call, insert record into processing_log table with: id (UUID), user_id, processing_type='sms_send', status (success/failure), input_metadata (redacted phone number last 4 digits only, message length), result_metadata (Twilio message SID, delivery status), error_message (if failed), processed_at timestamp. Never log full phone numbers or message content.",
            "status": "pending",
            "testStrategy": "Verify logs are created for both successful and failed sends. Confirm full phone numbers are not logged (only last 4 digits). Test that message content is excluded from logs. Verify Twilio SID and status are recorded.",
            "parentId": "undefined"
          },
          {
            "id": 7,
            "title": "Implement message templates for common use cases",
            "description": "Create reusable message template functions for verification codes, entry confirmations, and reminders to ensure consistent messaging.",
            "dependencies": [
              1
            ],
            "details": "Create template functions: `verificationCode(code: string)` returns 'Your Journalizer verification code is: {code}', `entryConfirmation()` returns 'Got it! Your entry has been saved. ', `reminder(type: string)` selects from predefined rotation of reminder messages. Export templates from sms.ts for use by other services. Keep templates concise for SMS character limits.",
            "status": "pending",
            "testStrategy": "Test each template function returns expected message format. Verify verificationCode correctly interpolates code. Test reminder rotation cycles through different messages. Confirm all messages fit within SMS length limits.",
            "parentId": "undefined"
          },
          {
            "id": 8,
            "title": "Create Glass specification for SMS service contract",
            "description": "Document the SMS service contract, intent, and guarantees in a Glass spec file following the GLASS.md framework conventions.",
            "dependencies": [
              3,
              4,
              5,
              6,
              7
            ],
            "details": "Create `glass/services/sms.glass` with: Intent section describing reliable SMS delivery for reminders/confirmations/verification. Contract section guaranteeing E.164 validation, comprehensive error handling, delivery tracking, exponential backoff for rate limits, and no PII in logs. Document sendSMS function signature, parameters, return type. List Twilio error codes handled. Specify logging behavior and privacy guarantees.",
            "status": "pending",
            "testStrategy": "Review Glass spec matches implementation. Verify all contracts are testable. Confirm intent clearly describes service purpose. Validate spec follows GLASS.md conventions from project.",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 8,
        "expansionPrompt": "Break down SMS service into: (1) implement sendSMS function using Twilio REST API (not SDK), (2) set up Basic Auth with ACCOUNT_SID and AUTH_TOKEN, (3) implement E.164 phone number validation, (4) handle Twilio error codes (21211 invalid number, 21614 trial limit, rate limits), (5) implement exponential backoff for rate limits, (6) log all SMS sends to processing_log (no PII), (7) implement message templates (verificationCode, entryConfirmation, reminder), (8) create Glass spec for services/sms.glass with delivery tracking contract"
      },
      {
        "id": "14",
        "title": "Create React SPA frontend with Vite build system",
        "description": "Initialize React single-page application with Vite, configure routing, authentication context, API client, and deploy to Cloudflare Pages or Workers static assets.",
        "details": "Run `npm create vite@latest frontend -- --template react-ts`.\n\nProject structure:\n```\nfrontend/\n  src/\n    App.tsx - Main app with routing\n    main.tsx - Entry point\n    pages/\n      Login.tsx - Google OAuth button\n      Dashboard.tsx - Entry timeline\n      EntryView.tsx - Single entry detail\n      NewEntry.tsx - Create entry form\n      Settings.tsx - User settings\n    components/\n      EntryCard.tsx - Entry display component\n      MediaPlayer.tsx - Audio/video player\n      Calendar.tsx - Calendar sidebar\n      Header.tsx - Navigation header\n    lib/\n      api.ts - Fetch wrapper with JWT\n      auth.ts - Auth context provider\n    types/\n      index.ts - TypeScript interfaces matching backend\n```\n\nInstall: react-router-dom, @tanstack/react-query (API state), date-fns (date formatting), tailwindcss (styling).\n\nAPI client handles:\n- JWT token in Authorization header\n- Automatic token refresh\n- Error handling and toast notifications\n- Request/response type safety\n\nDeploy: Build with Vite, upload to Cloudflare Pages, or serve from Workers using static asset handler.\n\nGlass spec:\n- `glass/frontend/app.glass` - Intent: web interface for journal management; Contract: guarantees authenticated API calls, responsive design, offline-first approach (optional)",
        "testStrategy": "Test dev server with `npm run dev`. Verify routing works. Test API client with authenticated requests. Test build output with `npm run build`. Deploy to staging and verify all routes work. Test on mobile viewport.",
        "priority": "high",
        "dependencies": [
          "4"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Initialize Vite React TypeScript project",
            "description": "Run npm create vite command to scaffold the frontend React application with TypeScript template and verify initial setup works.",
            "dependencies": [],
            "details": "Execute `npm create vite@latest frontend -- --template react-ts` in the project root. Navigate to frontend directory and run `npm install`. Test with `npm run dev` to ensure Vite dev server starts successfully. Verify TypeScript configuration is present and working. Check that basic React app renders at localhost.",
            "status": "pending",
            "testStrategy": "Run `npm run dev` and verify dev server starts without errors. Open browser to localhost:5173 and confirm React app loads. Run `npm run build` to verify TypeScript compilation succeeds.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Install core dependencies and configure Tailwind CSS",
            "description": "Install react-router-dom, @tanstack/react-query, date-fns, and tailwindcss with configuration.",
            "dependencies": [
              1
            ],
            "details": "Run `npm install react-router-dom @tanstack/react-query date-fns`. Install and configure Tailwind: `npm install -D tailwindcss postcss autoprefixer && npx tailwindcss init -p`. Update tailwind.config.js with content paths for src/**/*.{js,jsx,ts,tsx}. Create src/index.css with Tailwind directives (@tailwind base, components, utilities). Import index.css in main.tsx.",
            "status": "pending",
            "testStrategy": "Verify all packages are in package.json dependencies. Test Tailwind works by adding utility classes to App.tsx and confirming styles apply. Run dev server and check for CSS compilation errors.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Create project directory structure",
            "description": "Set up the complete frontend folder structure for pages, components, lib, and types directories.",
            "dependencies": [
              1
            ],
            "details": "Create directories: src/pages/, src/components/, src/lib/, src/types/. Create placeholder files: pages/Login.tsx, Dashboard.tsx, EntryView.tsx, NewEntry.tsx, Settings.tsx; components/EntryCard.tsx, MediaPlayer.tsx, Calendar.tsx, Header.tsx; lib/api.ts, auth.ts; types/index.ts. Each placeholder should export a basic functional component or empty object/interface to prevent import errors.",
            "status": "pending",
            "testStrategy": "Verify all directories exist using ls -R frontend/src. Confirm all placeholder files are created and contain valid TypeScript/React code that compiles without errors.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Define TypeScript interfaces matching backend schema",
            "description": "Create comprehensive TypeScript type definitions in types/index.ts that match the D1 database schema and API contracts.",
            "dependencies": [
              3
            ],
            "details": "In src/types/index.ts, define interfaces for: User (id, email, displayName, avatarUrl, phoneNumber, timezone, voiceStyle, createdAt), Entry (id, userId, rawContent, polishedContent, entryDate, type, source, tags, mood, location, processingStatus), Media (id, entryId, type, url, duration, transcription), Reminder (id, userId, title, message, scheduledFor), ApiResponse generic wrapper, PaginatedResponse<T>, AuthContextType. Include all fields from the backend schema.",
            "status": "pending",
            "testStrategy": "Run TypeScript compiler with `tsc --noEmit` and verify no type errors. Import types in other files to ensure exports work correctly. Verify interfaces match backend schema from Task 2.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement authentication context provider with JWT management",
            "description": "Create auth context that handles JWT token storage, refresh, and provides authentication state to the app.",
            "dependencies": [
              4
            ],
            "details": "In src/lib/auth.ts, create AuthContext using React Context API. Implement AuthProvider component that: stores JWT in localStorage, provides login/logout functions, exposes user state and isAuthenticated boolean, handles token expiration checks, provides getToken() function for API calls. Include useAuth() custom hook for consuming context. Handle initial token validation on app load. Implement automatic logout on token expiry.",
            "status": "pending",
            "testStrategy": "Test login flow stores token in localStorage. Verify useAuth hook provides correct authentication state. Test token expiration handling by manipulating expiry time. Verify logout clears token and updates state.",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Build API client wrapper with authentication and error handling",
            "description": "Create centralized API client in lib/api.ts with automatic JWT injection, token refresh, and comprehensive error handling.",
            "dependencies": [
              4,
              5
            ],
            "details": "In src/lib/api.ts, create fetchAPI wrapper function that: reads JWT from AuthContext, adds Authorization: Bearer <token> header, handles 401 responses with token refresh attempt, implements retry logic for failed requests, parses JSON responses with type safety, throws typed errors for different status codes. Export typed API methods: getEntries(), createEntry(), updateEntry(), deleteEntry(), etc. Include request/response interceptors for logging in development.",
            "status": "pending",
            "testStrategy": "Test authenticated requests include correct Authorization header. Verify 401 responses trigger token refresh. Test error handling for network failures and various HTTP status codes. Mock API responses and verify type safety.",
            "parentId": "undefined"
          },
          {
            "id": 7,
            "title": "Configure React Router with protected route guards",
            "description": "Set up client-side routing with react-router-dom including public and protected routes based on authentication state.",
            "dependencies": [
              3,
              5
            ],
            "details": "In src/App.tsx, configure BrowserRouter with routes: / (redirect to /dashboard or /login), /login (public), /dashboard (protected), /entry/:id (protected), /new (protected), /settings (protected). Create ProtectedRoute component that checks authentication via useAuth() and redirects to /login if unauthenticated. Wrap authenticated routes with ProtectedRoute. Configure React Query QueryClientProvider in App.tsx wrapping Router.",
            "status": "pending",
            "testStrategy": "Test unauthenticated users are redirected to /login when accessing protected routes. Verify authenticated users can access all routes. Test direct URL navigation works for all routes. Confirm browser back/forward buttons work correctly.",
            "parentId": "undefined"
          },
          {
            "id": 8,
            "title": "Implement toast notification system for error and success messages",
            "description": "Add global toast notification system for displaying API errors, success messages, and user feedback.",
            "dependencies": [
              2
            ],
            "details": "Install react-hot-toast or similar library: `npm install react-hot-toast`. Create src/lib/toast.ts with typed wrapper functions: showSuccess(), showError(), showInfo(). Add Toaster component to App.tsx. Integrate toast notifications in API client error handling to automatically show errors. Export useToast hook for manual toast triggering in components. Configure toast positioning, duration, and styling with Tailwind classes.",
            "status": "pending",
            "testStrategy": "Trigger API errors and verify toast notifications appear. Test success messages on successful operations. Verify toasts auto-dismiss after configured duration. Test multiple simultaneous toasts display correctly.",
            "parentId": "undefined"
          },
          {
            "id": 9,
            "title": "Create basic page components with routing integration",
            "description": "Implement skeleton components for all pages (Login, Dashboard, EntryView, NewEntry, Settings) with basic structure and navigation.",
            "dependencies": [
              7,
              8
            ],
            "details": "Implement each page component with: Login.tsx (Google OAuth button placeholder, form layout), Dashboard.tsx (header with navigation, entry list placeholder, calendar sidebar placeholder), EntryView.tsx (entry detail view with back button), NewEntry.tsx (form with text input, media upload placeholder), Settings.tsx (settings form with user preferences). Add Header component with navigation links and user menu. Ensure all pages use Tailwind for responsive layout.",
            "status": "pending",
            "testStrategy": "Navigate between all routes and verify page components render. Test responsive design at mobile and desktop viewports. Verify navigation links work correctly. Confirm Header appears on all protected pages.",
            "parentId": "undefined"
          },
          {
            "id": 10,
            "title": "Configure Vite build and deploy to Cloudflare Pages",
            "description": "Set up production build configuration and deploy the frontend to Cloudflare Pages with proper environment configuration.",
            "dependencies": [
              9
            ],
            "details": "Update vite.config.ts with build optimizations (chunk splitting, minification). Create .env.example with API_URL, GOOGLE_CLIENT_ID placeholders. Configure base URL for API calls based on environment. Run `npm run build` and verify dist/ output. Create wrangler.toml for Pages or use Cloudflare Pages dashboard. Deploy to Cloudflare Pages: connect Git repo or use `wrangler pages publish dist`. Configure environment variables in Cloudflare dashboard. Set up preview deployments for branches. Create glass/frontend/app.glass spec file documenting Intent (web interface for journal management) and Contract (authenticated API calls, responsive design).",
            "status": "pending",
            "testStrategy": "Run `npm run build` and verify no errors, check dist/ size is reasonable. Deploy to Cloudflare Pages staging environment. Test all routes work in production. Verify API calls use correct production URLs. Test on mobile devices and multiple browsers. Confirm environment variables are properly injected.",
            "parentId": "undefined"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 10,
        "expansionPrompt": "Break down frontend setup into: (1) run npm create vite with react-ts template, (2) set up React Router for client-side routing, (3) create auth context provider with JWT token management, (4) implement API client wrapper with Authorization header and token refresh, (5) install dependencies (react-router-dom, @tanstack/react-query, date-fns, tailwindcss), (6) create directory structure (pages/, components/, lib/, types/), (7) implement error handling and toast notifications, (8) set up TypeScript interfaces matching backend types, (9) configure Tailwind CSS, (10) deploy to Cloudflare Pages or configure Workers static asset handler, create Glass spec for frontend/app.glass"
      },
      {
        "id": "15",
        "title": "Build dashboard page with entry timeline, calendar, and search",
        "description": "Implement the main dashboard UI showing chronological journal entries with filtering, calendar sidebar, search functionality, and streak tracking as specified in PRD section 8.3.",
        "details": "Create `frontend/src/pages/Dashboard.tsx` matching the layout from PRD section 8.3:\n\nComponents:\n- **Header**: Logo, search input, settings icon, user avatar\n- **Calendar sidebar** (desktop): Calendar widget showing current month, days with entries highlighted (dot indicator)\n- **View toggles**: Month/Week/Day view (affects grouping and display)\n- **Entry timeline**: Scrollable list of EntryCard components, infinite scroll with react-query\n- **Entry card**: Shows date/time, entry type badge (SMS/Web), polished content (max 3 paragraphs preview), media thumbnails, \"View Original\" toggle, Edit/Audio buttons\n- **Stats footer**: Streak counter (consecutive days with entries), total entries this month\n\nImplementation:\n- Use react-query for entries list with pagination\n- Implement full-text search that queries GET /api/entries?search={query}\n- Calendar sidebar uses date-fns to render month grid, highlights dates with entries\n- Infinite scroll using Intersection Observer\n- \"View Original\" shows modal or side-by-side view of raw vs polished content\n- Click entry card to navigate to /entries/:id detail view\n\nGlass spec:\n- `glass/frontend/dashboard.glass` - Intent: primary journal viewing interface; Contract: guarantees performant rendering, accurate streak calculation, responsive search, accessible UI",
        "testStrategy": "Test with 0 entries, 1 entry, 100+ entries. Verify infinite scroll loads more entries. Test search with various queries. Verify calendar highlights correct dates. Test view toggles (Month/Week/Day). Test \"View Original\" toggle. Measure performance with large entry counts.",
        "priority": "high",
        "dependencies": [
          "14"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Dashboard.tsx page component with basic layout structure",
            "description": "Initialize the Dashboard page component in frontend/src/pages/Dashboard.tsx with the foundational layout structure including placeholders for header, sidebar, timeline, and footer sections.",
            "dependencies": [],
            "details": "Create the main Dashboard.tsx component file with basic React structure. Set up the page layout grid/flexbox to accommodate header at top, calendar sidebar on left (desktop only), main timeline in center, and stats footer at bottom. Use responsive design patterns (CSS Grid or Flexbox) to ensure mobile compatibility. Import necessary dependencies (React, react-query, date-fns). This establishes the foundation for all subsequent dashboard components.",
            "status": "pending",
            "testStrategy": "Verify component renders without errors. Test responsive layout on mobile and desktop viewports. Ensure placeholder sections appear in correct positions.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement header with search input, logo, and user avatar",
            "description": "Build the dashboard header containing logo, search input field, settings icon, and user avatar matching PRD section 8.3 specifications.",
            "dependencies": [
              1
            ],
            "details": "Create Header component within Dashboard.tsx or as separate component. Include: (1) Logo/branding element on left, (2) Search input field with placeholder text 'Search entries...', (3) Settings icon that links to /settings, (4) User avatar showing current user (integrate with auth context to get user data). Style header with appropriate spacing, alignment, and responsive behavior for mobile. Search input will be wired up to functionality in subtask 8.",
            "status": "pending",
            "testStrategy": "Verify all header elements render correctly. Test settings icon navigation. Verify user avatar displays current user info. Test header responsiveness on mobile devices.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement calendar sidebar with date-fns month grid rendering",
            "description": "Create calendar sidebar widget that renders the current month using date-fns library, displaying a proper calendar grid with day names and dates.",
            "dependencies": [
              1
            ],
            "details": "Create CalendarSidebar component using date-fns utilities. Implement: (1) Month header showing current month/year, (2) Grid of day names (Sun-Sat), (3) Calendar grid showing all dates in current month using date-fns functions like startOfMonth, endOfMonth, eachDayOfInterval, getDay for proper alignment, (4) Navigation arrows for prev/next month, (5) Hide on mobile/tablet viewports (desktop-only component). Style calendar with clean grid layout and proper spacing.",
            "status": "pending",
            "testStrategy": "Verify calendar renders correct number of days for current month. Test month navigation (prev/next). Verify calendar layout is correct with proper day alignment. Test visibility on different viewport sizes.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement calendar date highlighting logic for entries",
            "description": "Add logic to query entries by date and visually highlight calendar dates that have journal entries with dot indicators.",
            "dependencies": [
              3
            ],
            "details": "Extend CalendarSidebar to fetch entry dates from API. Create react-query hook to fetch GET /api/entries?fields=entryDate (or similar lightweight endpoint returning only dates). Process response to create Set or Map of dates with entries. For each calendar date cell, check if date exists in entries set and render dot indicator if true. Implement efficient date comparison logic using date-fns isSameDay or similar. Handle loading and error states for entry date fetching.",
            "status": "pending",
            "testStrategy": "Test with 0 entries (no highlights). Test with entries on specific dates and verify correct dates are highlighted. Test month navigation updates highlights correctly. Verify API query is efficient and doesn't fetch full entry data.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement view toggles (Month/Week/Day) with state management",
            "description": "Create view toggle controls allowing users to switch between Month, Week, and Day views, with state management to track selected view and affect timeline grouping.",
            "dependencies": [
              1
            ],
            "details": "Create ViewToggle component with three buttons: Month, Week, Day. Use React useState or context to manage selected view. Style active view with visual distinction. Position toggles above entry timeline section. Implement state that will be consumed by EntryTimeline component to determine grouping and display logic (Month groups by month, Week groups by week, Day shows individual days). Consider using URL query params to persist view preference (e.g., ?view=week).",
            "status": "pending",
            "testStrategy": "Test clicking each view toggle updates state correctly. Verify active view is visually indicated. Test that view preference persists on page refresh if using URL params. Verify state is accessible to timeline component.",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Create EntryCard component for timeline display",
            "description": "Build reusable EntryCard component that displays individual journal entries with date/time, type badge, content preview, media thumbnails, and action buttons.",
            "dependencies": [
              1
            ],
            "details": "Create EntryCard.tsx component accepting entry data as props. Render: (1) Date/time header using date-fns format, (2) Entry type badge (SMS/Web) with distinct styling, (3) Polished content preview (max 3 paragraphs with truncation), (4) Media thumbnails grid (if entry has media), (5) 'View Original' toggle button, (6) Edit and Audio action buttons, (7) Click handler for navigation to /entries/:id. Style card with clean design, appropriate padding, hover effects, and responsive layout. Support both compact and expanded states for different view modes.",
            "status": "pending",
            "testStrategy": "Test rendering with various entry types (text-only, with media, long content). Verify content truncation works correctly. Test media thumbnail display. Verify all buttons render and are clickable. Test card responsiveness on mobile.",
            "parentId": "undefined"
          },
          {
            "id": 7,
            "title": "Implement infinite scroll with react-query and Intersection Observer",
            "description": "Build the entry timeline with infinite scroll functionality using react-query for pagination and Intersection Observer API for detecting scroll position.",
            "dependencies": [
              5,
              6
            ],
            "details": "Create EntryTimeline component that uses react-query's useInfiniteQuery hook to fetch paginated entries from GET /api/entries?page={n}&limit={limit}. Implement Intersection Observer to detect when user scrolls near bottom of timeline and trigger fetchNextPage(). Group entries by selected view (Month/Week/Day) using date-fns grouping logic. Render EntryCard components for each entry. Handle loading states (initial load, loading more), error states, and empty state (no entries). Implement proper cleanup for Intersection Observer on unmount.",
            "status": "pending",
            "testStrategy": "Test with 0 entries shows empty state. Test with 1-10 entries renders correctly. Test with 100+ entries triggers infinite scroll. Verify scrolling to bottom loads next page. Test loading indicators appear correctly. Verify view toggle affects grouping.",
            "parentId": "undefined"
          },
          {
            "id": 8,
            "title": "Implement full-text search with debouncing and API integration",
            "description": "Wire up search input in header to perform full-text search against entries API with debouncing to minimize unnecessary requests.",
            "dependencies": [
              2,
              7
            ],
            "details": "In header search input, implement onChange handler with debouncing (300-500ms delay using useDebouncedValue or similar). When search value changes, update react-query to fetch GET /api/entries?search={query}. Replace/update the timeline's entry list with search results. Show loading indicator in search input during search. Handle empty search (revert to normal timeline). Show 'No results found' message when search returns 0 entries. Consider adding search result count display. Ensure search works across all view modes (Month/Week/Day).",
            "status": "pending",
            "testStrategy": "Test search with various queries and verify correct results. Test debouncing delays API calls appropriately. Test empty search returns to full timeline. Test search with no results shows appropriate message. Verify search loading states work correctly.",
            "parentId": "undefined"
          },
          {
            "id": 9,
            "title": "Implement 'View Original' toggle with modal or side-by-side view",
            "description": "Create functionality to toggle between polished and raw content views, showing a modal or side-by-side comparison when user clicks 'View Original' button.",
            "dependencies": [
              6
            ],
            "details": "In EntryCard component, implement 'View Original' button click handler. Options: (1) Modal approach - show dialog/modal with tabs or split view showing raw vs polished content, or (2) Inline approach - expand card to show both versions side-by-side. Implement state management for which entry's original is being viewed. Include close/dismiss functionality. Style raw content with monospace font or distinct styling to differentiate from polished. Handle cases where raw and polished are identical or when raw content is empty.",
            "status": "pending",
            "testStrategy": "Test clicking 'View Original' opens modal/expands card correctly. Verify raw and polished content both display. Test closing/dismissing view. Test with entries having identical raw/polished content. Test with long raw content.",
            "parentId": "undefined"
          },
          {
            "id": 10,
            "title": "Implement entry navigation to detail view /entries/:id",
            "description": "Add click handler to EntryCard that navigates user to detailed entry view page at /entries/:id when card is clicked.",
            "dependencies": [
              6
            ],
            "details": "In EntryCard component, add onClick handler to card container (excluding action buttons) that uses React Router's useNavigate() to navigate to /entries/:id where id is the entry's unique identifier. Ensure click doesn't fire when clicking buttons (Edit, Audio, View Original) using event.stopPropagation() on button clicks. Add visual affordance (cursor pointer, hover effect) to indicate card is clickable. Consider adding keyboard navigation support (Enter key) for accessibility.",
            "status": "pending",
            "testStrategy": "Test clicking entry card navigates to correct detail page. Verify clicking action buttons doesn't trigger navigation. Test navigation preserves view state (back button returns to same view). Test keyboard navigation if implemented.",
            "parentId": "undefined"
          },
          {
            "id": 11,
            "title": "Implement streak counter logic for consecutive days calculation",
            "description": "Build streak calculation logic that determines consecutive days with journal entries and displays current streak count in stats footer.",
            "dependencies": [
              7
            ],
            "details": "Create utility function calculateStreak(entries) that: (1) Groups entries by date, (2) Sorts dates descending from today, (3) Counts consecutive days with at least one entry starting from today (or most recent entry date), (4) Returns streak count. Use date-fns functions like isSameDay, differenceInDays, parseISO for date logic. Fetch all entry dates (not full entries) for current user. Display streak in footer with icon/label (e.g., ' 7 day streak'). Handle edge cases: no entries (0 streak), broken streak (show last streak?), same-day multiple entries.",
            "status": "pending",
            "testStrategy": "Test with 0 entries shows 0 streak. Test with entries on consecutive days calculates correct streak. Test with gap in entries resets streak correctly. Test with multiple entries same day counts as 1 day. Test streak updates when new entry is added.",
            "parentId": "undefined"
          },
          {
            "id": 12,
            "title": "Implement monthly entry count in stats footer",
            "description": "Calculate and display total number of journal entries created in the current month in the dashboard stats footer.",
            "dependencies": [
              7
            ],
            "details": "Create utility or react-query hook to count entries in current month. Query GET /api/entries with date range filter (startOfMonth to endOfMonth using date-fns) or use client-side filtering if all entries are already loaded. Display count in stats footer with label (e.g., '42 entries this month'). Update count when: (1) Month changes (calendar navigation), (2) New entry is created, (3) Entry is deleted. Consider showing additional stats like entries this week or today for enhanced engagement.",
            "status": "pending",
            "testStrategy": "Test count is correct for current month with various entry counts. Test count updates when month changes. Verify count updates when entry is added/deleted. Test with 0 entries in current month.",
            "parentId": "undefined"
          },
          {
            "id": 13,
            "title": "Create Glass spec for frontend/dashboard.glass with performance contract",
            "description": "Write Glass framework specification file documenting dashboard component's intent, contract, guarantees for performance, accessibility, and functionality.",
            "dependencies": [
              1,
              2,
              3,
              4,
              5,
              6,
              7,
              8,
              9,
              10,
              11,
              12
            ],
            "details": "Create glass/frontend/dashboard.glass following GLASS.md format. Document: (1) Intent - primary journal viewing interface with filtering and navigation, (2) Contract - guarantees including: performant rendering with 100+ entries (< 100ms initial render), accurate streak calculation (consecutive days logic), responsive search with debouncing, infinite scroll without layout shift, accessible UI (keyboard nav, ARIA labels, screen reader support), calendar highlights match entry dates, (3) Dependencies on API endpoints, auth context, (4) Integration points with EntryCard, settings, detail views. Include performance benchmarks and accessibility requirements (WCAG 2.1 AA compliance).",
            "status": "pending",
            "testStrategy": "Review Glass spec against GLASS.md format requirements. Verify all contracts are testable and measurable. Ensure performance metrics are specific and achievable. Cross-reference with dashboard implementation to ensure accuracy.",
            "parentId": "undefined"
          }
        ],
        "complexity": 8,
        "recommendedSubtasks": 13,
        "expansionPrompt": "Break down dashboard into: (1) create Dashboard.tsx page component, (2) implement header with search input and user avatar, (3) implement calendar sidebar using date-fns for month grid, (4) implement calendar date highlighting logic (query entries by date), (5) implement view toggles (Month/Week/Day) with state management, (6) create EntryCard component for timeline, (7) implement infinite scroll using Intersection Observer and react-query, (8) implement full-text search with debouncing, (9) implement 'View Original' toggle (modal or side-by-side), (10) implement entry navigation to /entries/:id, (11) implement streak counter logic (consecutive days calculation), (12) implement monthly entry count, (13) create Glass spec for frontend/dashboard.glass with performance contract"
      },
      {
        "id": "16",
        "title": "Build new entry creation form with media upload and AI toggle",
        "description": "Implement web-based entry creation interface with text editor, file upload for photos/audio/video, in-browser audio recording, mood selector, tags, and optional AI polish toggle.",
        "details": "Create `frontend/src/pages/NewEntry.tsx` matching PRD section 8.3 layout:\n\n**Form fields:**\n- Date picker (defaults to today, can select past dates)\n- Textarea for entry content (markdown support optional)\n- File upload buttons: Photo, Audio, Video (accept multiple)\n- In-browser audio recording using MediaRecorder API (record/stop/play buttons)\n- AI polish checkbox (default: checked)\n- Tags input (comma-separated or autocomplete)\n- Mood selector (emoji buttons:     )\n- Location field (optional, future: geolocation)\n- Save button\n\n**Implementation:**\n- Upload media files to POST /api/media/upload first, get media IDs\n- On save, POST /api/entries with { rawContent, entryDate, tags, mood, mediaIds, polishWithAI }\n- Show loading indicator during AI polish (may take 3-10 seconds)\n- On success, navigate to entry detail or dashboard\n- Autosave draft to localStorage every 30 seconds\n\n**Audio recording:**\n- Use MediaRecorder API with getUserMedia()\n- Record as WebM or MP3\n- Show waveform visualization (optional)\n- Preview playback before saving\n\nGlass spec:\n- `glass/frontend/new-entry.glass` - Intent: web-based entry creation; Contract: guarantees media upload success, autosave functionality, audio recording compatibility, form validation",
        "testStrategy": "Test creating entries with text only, with photos, with audio (recorded and uploaded), with video. Test AI polish toggle on/off. Test mood and tags. Verify autosave works. Test date picker past dates. Test on different browsers for MediaRecorder support.",
        "priority": "high",
        "dependencies": [
          "14",
          "15"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create NewEntry.tsx with basic form structure and state management",
            "description": "Set up the NewEntry page component with React state management for all form fields including content, date, tags, mood, location, AI polish toggle, and media files.",
            "dependencies": [],
            "details": "Create `frontend/src/pages/NewEntry.tsx` with useState hooks for: entryContent (string), entryDate (Date), tags (string[]), mood (string), location (string), polishWithAI (boolean, default true), uploadedMedia (File[]), recordedAudio (Blob | null), mediaIds (string[]). Set up form structure with proper TypeScript types. Initialize entryDate to current date. Create form submission handler stub.",
            "status": "pending",
            "testStrategy": "Verify component renders without errors. Test that state updates correctly when form fields change. Confirm default values are set (date=today, polishWithAI=true).",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement date picker with past date selection capability",
            "description": "Add a date picker input that defaults to today's date but allows users to select any past date for journal entries.",
            "dependencies": [
              1
            ],
            "details": "Use HTML5 date input or a React date picker library (like react-datepicker). Set max attribute to today's date to prevent future dates. Default value should be current date. Wire up onChange handler to update entryDate state. Format date properly for API submission (ISO format).",
            "status": "pending",
            "testStrategy": "Test that default date is today. Verify users can select past dates but not future dates. Confirm date format is correct for API.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement textarea for entry content with optional markdown support",
            "description": "Create a textarea input for journal entry content with optional markdown rendering preview.",
            "dependencies": [
              1
            ],
            "details": "Add textarea element with appropriate styling and placeholder text. Wire up to entryContent state. Optionally implement markdown preview using a library like react-markdown. Add character count indicator. Ensure textarea expands with content or has sufficient height. Apply proper styling for readability.",
            "status": "pending",
            "testStrategy": "Test typing in textarea updates state. Verify markdown preview renders correctly if implemented. Test with long content to ensure proper scrolling/expansion.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement file upload UI for photos, audio, and video",
            "description": "Create file upload buttons for photos, audio, and video files with support for multiple file selection and preview.",
            "dependencies": [
              1
            ],
            "details": "Create three file input elements with appropriate accept attributes: photos (image/*), audio (audio/*), video (video/*). Set multiple attribute to allow multiple file selection. Add visual upload buttons/zones with icons. Implement file preview functionality showing thumbnails for images, file names for audio/video. Store selected files in uploadedMedia state. Add ability to remove files before submission. Validate file types and sizes (e.g., max 50MB per file).",
            "status": "pending",
            "testStrategy": "Test uploading single and multiple files of each type. Verify file type validation rejects invalid files. Test file preview display. Confirm ability to remove files. Test file size validation.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement MediaRecorder API integration for in-browser audio recording",
            "description": "Set up MediaRecorder API with getUserMedia() to enable in-browser audio recording functionality.",
            "dependencies": [
              1
            ],
            "details": "Request microphone permissions using navigator.mediaDevices.getUserMedia({ audio: true }). Initialize MediaRecorder instance with appropriate MIME type (prefer audio/webm, fallback to audio/mp4 or audio/ogg). Handle browser compatibility checks and display appropriate error messages for unsupported browsers. Store recorded audio chunks in state. Implement error handling for permission denied scenarios. Create state variables for recording status (idle, recording, stopped) and recorded blob.",
            "status": "pending",
            "testStrategy": "Test microphone permission request flow. Verify recording works in Chrome, Firefox, Safari. Test permission denied scenario displays appropriate error. Confirm audio chunks are captured correctly.",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Add record/stop/play controls for audio recording with playback preview",
            "description": "Implement UI controls for starting/stopping audio recording and playing back the recorded audio before submission.",
            "dependencies": [
              5
            ],
            "details": "Create three buttons: Record (start recording), Stop (stop recording), Play (preview playback). Update button states based on recording status (disable Record during recording, enable Stop only during recording, enable Play only when audio exists). Implement start recording handler that calls mediaRecorder.start(). Implement stop handler that calls mediaRecorder.stop() and saves blob. Create audio element for playback preview using URL.createObjectURL(). Add recording duration timer. Optionally implement waveform visualization using Web Audio API or a library like wavesurfer.js. Show visual feedback during recording (e.g., red dot, pulsing animation).",
            "status": "pending",
            "testStrategy": "Test complete recording flow: click Record, speak, click Stop, click Play. Verify playback matches recording. Test that recording timer displays correctly. Verify button states change appropriately. Test re-recording replaces previous audio.",
            "parentId": "undefined"
          },
          {
            "id": 7,
            "title": "Implement AI polish checkbox with default checked state",
            "description": "Add a checkbox input for the AI polish feature that defaults to checked, allowing users to opt out of AI processing.",
            "dependencies": [
              1
            ],
            "details": "Create checkbox input element labeled 'Polish with AI' or similar. Wire up to polishWithAI state (boolean, default true). Add informational tooltip or help text explaining that AI polish may take 3-10 seconds. Style checkbox for visibility. Ensure checked state persists if user navigates away and returns (via localStorage autosave).",
            "status": "pending",
            "testStrategy": "Verify checkbox defaults to checked on initial render. Test toggling checkbox updates state. Confirm help text is clear and informative.",
            "parentId": "undefined"
          },
          {
            "id": 8,
            "title": "Implement tags input with comma-separated parsing or autocomplete",
            "description": "Create a tags input field that allows users to enter comma-separated tags or select from autocomplete suggestions.",
            "dependencies": [
              1
            ],
            "details": "Implement tags input using either: (1) simple text input with comma-separated parsing on blur/submit, or (2) autocomplete component (e.g., react-select or custom implementation) with multi-select capability. Store tags as string array in state. If using autocomplete, fetch existing tags from API endpoint (GET /api/tags) to populate suggestions. Display entered tags as removable chips/badges. Trim whitespace and convert to lowercase for consistency. Allow adding new tags not in suggestions.",
            "status": "pending",
            "testStrategy": "Test entering comma-separated tags and verify parsing into array. Test autocomplete suggestions if implemented. Verify tags display as chips. Test removing individual tags. Confirm tags array format is correct for API submission.",
            "parentId": "undefined"
          },
          {
            "id": 9,
            "title": "Implement mood selector with emoji buttons",
            "description": "Create a mood selector UI using emoji buttons for the five mood options: happy, neutral, sad, angry, and thoughtful.",
            "dependencies": [
              1
            ],
            "details": "Create five button elements with emojis:  (happy),  (neutral),  (sad),  (angry),  (thoughtful). Store selected mood as string in state (e.g., 'happy', 'neutral'). Implement single-select behavior (clicking a mood deselects others). Add visual indication for selected mood (border, background color, scale). Make mood selection optional (allow deselecting). Ensure proper spacing and touch-friendly sizes for mobile.",
            "status": "pending",
            "testStrategy": "Test clicking each emoji selects that mood. Verify only one mood can be selected at a time. Test deselecting mood. Confirm selected mood visual feedback is clear. Test on mobile for touch usability.",
            "parentId": "undefined"
          },
          {
            "id": 10,
            "title": "Implement optional location field with future geolocation support",
            "description": "Add a location text input field that is optional, with placeholder for future geolocation integration.",
            "dependencies": [
              1
            ],
            "details": "Create text input for location with placeholder like 'Add location (optional)'. Wire up to location state. Add comment or TODO for future geolocation API integration (navigator.geolocation.getCurrentPosition). Style input consistently with other form fields. Location should be optional and not required for form submission.",
            "status": "pending",
            "testStrategy": "Test typing in location field updates state. Verify location is optional and form can be submitted without it. Confirm placeholder text is clear.",
            "parentId": "undefined"
          },
          {
            "id": 11,
            "title": "Handle media upload to POST /api/media/upload and track media IDs",
            "description": "Implement functionality to upload media files to the API endpoint first, retrieve media IDs, and track them for entry creation.",
            "dependencies": [
              4,
              6
            ],
            "details": "Create async function uploadMediaFiles() that iterates through uploadedMedia array and recordedAudio blob. For each file/blob, create FormData and POST to /api/media/upload endpoint. Extract media ID from response and store in mediaIds state array. Show upload progress indicator for each file. Handle upload errors gracefully with retry option. Upload media files BEFORE submitting the entry form. Include proper headers and authentication token in fetch request.",
            "status": "pending",
            "testStrategy": "Test uploading single and multiple media files. Verify media IDs are returned and stored correctly. Test upload progress indicator displays. Test error handling when upload fails. Confirm uploaded files are accessible via returned media IDs.",
            "parentId": "undefined"
          },
          {
            "id": 12,
            "title": "Implement form submission to POST /api/entries with loading state",
            "description": "Create form submission handler that posts entry data to the API with loading indicators during AI polish processing.",
            "dependencies": [
              2,
              3,
              7,
              8,
              9,
              10,
              11
            ],
            "details": "Implement handleSubmit async function that: (1) validates required fields (content, date), (2) calls uploadMediaFiles() to get mediaIds, (3) constructs request body with { rawContent, entryDate, tags, mood, location, mediaIds, polishWithAI }, (4) POSTs to /api/entries endpoint with authentication, (5) shows loading spinner with message 'Processing with AI...' if polishWithAI is true (3-10 seconds expected), (6) handles success by clearing form and navigating to entry detail page or dashboard, (7) handles errors with user-friendly messages. Disable submit button during submission to prevent double-submission.",
            "status": "pending",
            "testStrategy": "Test submitting entry with all fields populated. Test with only required fields. Verify loading indicator shows during AI polish. Test error handling for network failures and validation errors. Confirm successful submission navigates to correct page. Test that submit button is disabled during submission.",
            "parentId": "undefined"
          },
          {
            "id": 13,
            "title": "Implement autosave to localStorage every 30 seconds",
            "description": "Set up automatic draft saving to browser localStorage at 30-second intervals to prevent data loss.",
            "dependencies": [
              1
            ],
            "details": "Use useEffect hook with setInterval to save form state to localStorage every 30 seconds. Create autosave key like 'journalizer_draft'. Save object containing all form fields: { entryContent, entryDate, tags, mood, location, polishWithAI }. On component mount, check localStorage for existing draft and populate form if found. Clear localStorage draft after successful submission. Show visual indicator when autosave occurs (e.g., 'Draft saved' toast). Handle edge cases like browser storage limits. Note: uploaded files and recorded audio may not be saved to localStorage due to size limits.",
            "status": "pending",
            "testStrategy": "Test that draft saves to localStorage after 30 seconds. Verify draft is restored when navigating back to form. Confirm draft is cleared after successful submission. Test autosave indicator displays. Test behavior when localStorage is full or disabled.",
            "parentId": "undefined"
          },
          {
            "id": 14,
            "title": "Create Glass spec for frontend/new-entry.glass with contracts",
            "description": "Write Glass specification file documenting the NewEntry component's intent, contracts, and guarantees for media upload, autosave, and audio recording.",
            "dependencies": [
              12,
              13
            ],
            "details": "Create `glass/frontend/new-entry.glass` file following the Glass Framework format defined in GLASS.md. Document: (1) Intent: web-based entry creation with rich media support, (2) Contract: guarantees media upload success or error handling, autosave functionality every 30 seconds, audio recording browser compatibility checks, form validation for required fields, (3) Expectations: users have valid authentication, browser supports minimum required APIs, (4) Constraints: file size limits, audio recording format compatibility. Include examples of successful entry creation flow and error scenarios.",
            "status": "pending",
            "testStrategy": "Review Glass spec for completeness against GLASS.md format. Verify all contracts are testable. Confirm spec accurately reflects implementation. Validate that autosave, media upload, and audio recording contracts are clearly defined.",
            "parentId": "undefined"
          }
        ],
        "complexity": 9,
        "recommendedSubtasks": 14,
        "expansionPrompt": "Break down new entry form into: (1) create NewEntry.tsx with form state management, (2) implement date picker with past date selection, (3) implement textarea for entry content with markdown support, (4) implement file upload UI for photos/audio/video, (5) implement MediaRecorder API for in-browser audio recording, (6) add record/stop/play controls for audio recording, (7) implement AI polish checkbox (default checked), (8) implement tags input with comma-separated parsing or autocomplete, (9) implement mood selector with emoji buttons, (10) implement location field, (11) handle media upload to POST /api/media/upload endpoint, (12) implement form submission to POST /api/entries with loading state, (13) implement autosave to localStorage every 30 seconds, (14) create Glass spec for frontend/new-entry.glass with autosave contract"
      },
      {
        "id": "17",
        "title": "Implement settings page with voice preferences, phone verification, and reminders UI",
        "description": "Build comprehensive settings interface for profile management, AI voice customization, phone verification workflow, reminder configuration, and data export options.",
        "details": "Create `frontend/src/pages/Settings.tsx` matching PRD section 8.3 layout:\n\n**Sections:**\n\n1. **Profile**\n   - Display name input\n   - Email (read-only, from Google)\n   - Timezone dropdown (IANA zones)\n\n2. **SMS Journaling**\n   - Phone number input (E.164 format with country code dropdown)\n   - \"Verify\" button (triggers POST /api/settings/verify-phone)\n   - Verification modal: 6-digit code input, \"Confirm\" button\n   - Status indicator:  Verified or  Unverified\n\n3. **AI Voice Preferences**\n   - Voice style dropdown: Natural, Conversational, Reflective, Polished\n   - Custom instructions textarea (500 char limit)\n   - \"Test AI\" button (shows before/after example)\n\n4. **Reminders**\n   - Daily reminder checkbox + time picker\n   - Weekly reminder checkbox + day selector + time picker\n   - Monthly reminder checkbox + day of month (1-28) + time picker\n   - Smart nudge checkbox + threshold slider (1-14 days)\n   - All reminders show active/inactive toggle\n\n5. **Data**\n   - \"Export All Entries\" button (downloads JSON)\n   - \"Export as PDF\" button (future: print-ready format)\n\n6. **Print Subscription** (Phase 2, show \"Coming Soon\" placeholder)\n\nValidation:\n- E.164 phone format\n- Timezone from valid list\n- Time fields HH:MM format\n\nGlass spec:\n- `glass/frontend/settings.glass` - Intent: user preference management UI; Contract: guarantees input validation, phone verification flow, reminder configuration persistence, data export functionality",
        "testStrategy": "Test updating each setting field and verify API calls succeed. Test phone verification flow end-to-end. Test invalid phone formats are rejected. Test all reminder configurations save correctly. Test data export downloads valid JSON. Test timezone changes affect reminder display.",
        "priority": "high",
        "dependencies": [
          "14",
          "15"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Settings.tsx with multi-section layout structure",
            "description": "Initialize Settings page component with sections for Profile, SMS Journaling, AI Voice Preferences, Reminders, Data Export, and Print Subscription placeholder.",
            "dependencies": [],
            "details": "Create `frontend/src/pages/Settings.tsx` with React component structure. Define section containers for: (1) Profile, (2) SMS Journaling, (3) AI Voice Preferences, (4) Reminders, (5) Data, (6) Print Subscription. Add section headers and basic layout styling. Import necessary UI components (form inputs, buttons, modals). Set up component state management structure for form fields.",
            "status": "pending",
            "testStrategy": "Verify all sections render correctly with proper headings and layout spacing.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement profile section with display name, email, and timezone",
            "description": "Build profile section with display name input (editable), email field (read-only from Google OAuth), and timezone dropdown placeholder.",
            "dependencies": [
              1
            ],
            "details": "Add form fields to Profile section: (1) Display name text input with state binding, (2) Email input field marked read-only and populated from auth context/user data, (3) Timezone dropdown component (initially empty select, will be populated in next subtask). Wire up state management for display name changes. Add form validation for required fields.",
            "status": "pending",
            "testStrategy": "Test display name input updates state. Verify email field is read-only and displays user's Google email. Confirm timezone dropdown renders.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Populate timezone dropdown with IANA timezone options",
            "description": "Integrate IANA timezone database into timezone dropdown with proper formatting and user-friendly display.",
            "dependencies": [
              2
            ],
            "details": "Import IANA timezone list (use library like `countries-and-timezones` or manual list). Populate timezone dropdown with all valid IANA zones (e.g., 'America/New_York', 'Europe/London'). Format display names for readability (show UTC offset). Set user's current timezone as default selection. Ensure dropdown supports search/filter for hundreds of options.",
            "status": "pending",
            "testStrategy": "Verify dropdown contains all IANA timezones. Test search/filter functionality. Confirm user's current timezone is pre-selected.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement SMS journaling section with phone input and country code",
            "description": "Build phone number input field with country code dropdown supporting E.164 format validation.",
            "dependencies": [
              1
            ],
            "details": "Create SMS Journaling section with: (1) Country code dropdown (e.g., +1, +44, +91) using library like `react-phone-number-input` or custom implementation, (2) Phone number input field that combines with country code to form E.164 format, (3) Client-side validation for E.164 format (+ followed by country code and number), (4) 'Verify' button (initially disabled until valid phone entered). Add state management for phone number and country code.",
            "status": "pending",
            "testStrategy": "Test phone number validation accepts only valid E.164 formats. Verify country code dropdown includes major countries. Test 'Verify' button enables/disables based on input validity.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement phone verification trigger API call",
            "description": "Wire 'Verify' button to trigger POST /api/settings/verify-phone and handle response states.",
            "dependencies": [
              4
            ],
            "details": "Implement onClick handler for 'Verify' button that: (1) Makes POST request to /api/settings/verify-phone with phone number in E.164 format, (2) Handles loading state (disable button, show spinner), (3) Handles success response (opens verification modal), (4) Handles error responses (invalid phone, rate limit, server error) with user-friendly error messages. Add error state management and display error messages below phone input.",
            "status": "pending",
            "testStrategy": "Test API call triggers on button click with correct payload. Verify loading state displays. Test error handling for various API error responses. Confirm success opens verification modal.",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Create verification modal with 6-digit code input UI",
            "description": "Build modal component for phone verification code entry with 6-digit input field and confirm button.",
            "dependencies": [
              5
            ],
            "details": "Create VerificationModal component with: (1) Modal overlay and container, (2) Header text explaining verification, (3) 6-digit code input (can use separate inputs for each digit or single masked input), (4) 'Confirm' button, (5) 'Resend Code' link, (6) 'Cancel' button to close modal. Add input validation to ensure exactly 6 digits entered. Auto-focus on first input when modal opens. Add state management for verification code and modal visibility.",
            "status": "pending",
            "testStrategy": "Test modal opens/closes correctly. Verify 6-digit input accepts only numbers. Test 'Confirm' button disabled until 6 digits entered. Test auto-focus behavior.",
            "parentId": "undefined"
          },
          {
            "id": 7,
            "title": "Implement verification confirmation API call",
            "description": "Wire verification modal 'Confirm' button to POST /api/settings/confirm-phone and handle verification result.",
            "dependencies": [
              6
            ],
            "details": "Implement confirmation handler that: (1) Makes POST request to /api/settings/confirm-phone with 6-digit code and phone number, (2) Handles loading state during verification, (3) On success: closes modal, updates verification status indicator, shows success toast/message, (4) On failure (invalid code, expired code, server error): displays error in modal, allows retry without closing modal. Add retry logic and error state management.",
            "status": "pending",
            "testStrategy": "Test API call sends correct verification code. Verify success flow closes modal and updates UI. Test error handling for invalid/expired codes. Confirm retry mechanism works.",
            "parentId": "undefined"
          },
          {
            "id": 8,
            "title": "Add phone verification status indicator",
            "description": "Display real-time verification status with visual indicators (verified checkmark or unverified warning).",
            "dependencies": [
              7
            ],
            "details": "Add status indicator below phone input showing: (1)  'Verified' with green styling when phone_verified=true, (2)  'Unverified' with yellow/warning styling when phone_verified=false or null, (3) Fetch initial verification status from user settings API on page load, (4) Update status dynamically after successful verification. Style indicators with appropriate colors and icons.",
            "status": "pending",
            "testStrategy": "Test verified status displays checkmark and correct text. Test unverified status displays warning. Verify status updates immediately after successful verification.",
            "parentId": "undefined"
          },
          {
            "id": 9,
            "title": "Implement AI voice preferences section",
            "description": "Build voice customization UI with style dropdown, custom instructions textarea, and test preview functionality.",
            "dependencies": [
              1
            ],
            "details": "Create AI Voice Preferences section with: (1) Voice style dropdown with options: 'Natural', 'Conversational', 'Reflective', 'Polished', (2) Custom instructions textarea with 500 character limit and character counter, (3) 'Test AI' button that shows before/after example of voice transformation (can mock initially or call test endpoint), (4) State management for selected style and custom instructions. Add character count validation and visual feedback when approaching limit.",
            "status": "pending",
            "testStrategy": "Test dropdown allows selection of all voice styles. Verify textarea enforces 500 character limit. Test 'Test AI' button shows preview (mock response acceptable initially). Confirm character counter updates correctly.",
            "parentId": "undefined"
          },
          {
            "id": 10,
            "title": "Implement reminders section with daily/weekly/monthly/smart configurations",
            "description": "Build comprehensive reminder configuration UI with conditional inputs for different reminder types and active/inactive toggles.",
            "dependencies": [
              1
            ],
            "details": "Create Reminders section with four reminder types: (1) Daily reminder: checkbox + time picker (HH:MM format), (2) Weekly reminder: checkbox + day selector (Mon-Sun) + time picker, (3) Monthly reminder: checkbox + day of month input (1-28) + time picker, (4) Smart nudge: checkbox + threshold slider (1-14 days). Each reminder has active/inactive toggle. Implement conditional rendering (show day selector only when weekly checked, etc.). Add time picker component or use HTML time input. Validate all time inputs are HH:MM format. Add state management for all reminder configurations.",
            "status": "pending",
            "testStrategy": "Test each reminder type checkbox shows/hides conditional fields. Verify time pickers accept valid HH:MM format only. Test day selector for weekly allows Mon-Sun selection. Test monthly day input validates 1-28 range. Test smart nudge slider stays within 1-14 range. Verify active/inactive toggles work.",
            "parentId": "undefined"
          },
          {
            "id": 11,
            "title": "Implement data export buttons with download functionality",
            "description": "Add export buttons that trigger JSON and PDF downloads of user's journal entries.",
            "dependencies": [
              1
            ],
            "details": "Create Data section with two export buttons: (1) 'Export All Entries' button that triggers GET /api/export/json and downloads resulting JSON file, (2) 'Export as PDF' button (show disabled state or 'Coming Soon' label for Phase 2). Implement download handler that: fetches export data, creates blob, triggers browser download with appropriate filename (e.g., 'journal-entries-YYYY-MM-DD.json'). Add loading states during export generation. Handle export errors gracefully.",
            "status": "pending",
            "testStrategy": "Test 'Export All Entries' triggers download of valid JSON file. Verify filename includes date. Test loading state displays during export. Test error handling if export fails. Confirm PDF button shows as disabled/coming soon.",
            "parentId": "undefined"
          },
          {
            "id": 12,
            "title": "Add print subscription placeholder section",
            "description": "Create placeholder UI for future print subscription feature marked as 'Coming Soon'.",
            "dependencies": [
              1
            ],
            "details": "Create Print Subscription section with: (1) Section header 'Print Subscription', (2) 'Coming Soon' badge or label, (3) Brief description text explaining future feature (e.g., 'Get beautiful printed copies of your journal delivered monthly'), (4) Disabled state styling to indicate not yet available. Style consistently with other sections but clearly marked as unavailable.",
            "status": "pending",
            "testStrategy": "Verify section renders with 'Coming Soon' indicator. Confirm section is styled but non-interactive. Test layout consistency with other sections.",
            "parentId": "undefined"
          },
          {
            "id": 13,
            "title": "Create Glass spec for settings frontend validation contract",
            "description": "Document Glass specification for settings page with validation rules, phone verification flow, and data contracts.",
            "dependencies": [
              2,
              3,
              4,
              5,
              6,
              7,
              8,
              9,
              10,
              11,
              12
            ],
            "details": "Create `glass/frontend/settings.glass` file with: (1) Intent: 'User preference management UI for profile, phone verification, AI voice, reminders, and data export', (2) Contract: guarantees E.164 phone format validation, IANA timezone validation, HH:MM time format validation, reminder day/threshold range validation (weekly 0-6, monthly 1-28, smart 1-14), phone verification flow (verify  modal  confirm  status update), 500 char limit on AI instructions, data export functionality. (3) Dependencies: auth context for user data, API endpoints for verify-phone, confirm-phone, reminders CRUD, export. Follow GLASS.md format conventions.",
            "status": "pending",
            "testStrategy": "Review Glass spec matches implementation. Verify all validation rules documented. Confirm contract covers all critical guarantees (phone verification flow, input validation, API integration).",
            "parentId": "undefined"
          }
        ],
        "complexity": 8,
        "recommendedSubtasks": 13,
        "expansionPrompt": "Break down settings page into: (1) create Settings.tsx with section layout, (2) implement profile section (display name, email read-only, timezone dropdown), (3) populate timezone dropdown with IANA zones, (4) implement SMS journaling section with phone input and country code dropdown, (5) implement phone verification flow (trigger POST /api/settings/verify-phone), (6) create verification modal with 6-digit code input, (7) implement verification confirmation (POST /api/settings/confirm-phone), (8) add verification status indicator, (9) implement AI voice preferences (style dropdown, custom instructions textarea), (10) implement reminders section with daily/weekly/monthly/smart toggles and time/day pickers, (11) implement data export buttons (JSON/PDF), (12) add print subscription placeholder (Coming Soon), (13) create Glass spec for frontend/settings.glass with validation contract"
      },
      {
        "id": "18",
        "title": "Build entry detail view with media player and edit functionality",
        "description": "Create single entry detail page showing full content, all media attachments with inline players, original/polished toggle, and edit capabilities.",
        "details": "Create `frontend/src/pages/EntryView.tsx` for route `/entries/:id`.\n\n**Layout:**\n- Back button to dashboard\n- Entry metadata: date, time, source badge (SMS/Web)\n- Polished content display (full text, markdown rendering)\n- \"View Original\" toggle button (shows raw content side-by-side or replaces polished)\n- Media gallery:\n  - Photos: Grid layout, lightbox on click\n  - Audio: Custom audio player with waveform, play/pause, seek bar, duration\n  - Video: HTML5 video player with controls\n  - For audio/video with transcriptions: Show transcript below player\n- Tags display (clickable, filters dashboard by tag)\n- Mood indicator\n- Edit button (opens edit modal or inline editor)\n- Delete button (confirmation modal)\n\n**Edit functionality:**\n- Inline editing of polished content (not raw)\n- Add/remove tags\n- Change mood\n- Save triggers PUT /api/entries/:id\n\n**Media player requirements:**\n- Use Howler.js or Wavesurfer.js for audio\n- Lazy load video\n- Show loading states\n\nGlass spec:\n- `glass/frontend/entry-view.glass` - Intent: detailed entry viewing and editing; Contract: guarantees media playback, edit persistence, delete confirmation, original content preservation",
        "testStrategy": "Test loading entries with different media types. Test audio/video playback. Test original/polished toggle. Test editing content and tags. Test delete with confirmation. Verify back navigation. Test on mobile viewport.",
        "priority": "medium",
        "dependencies": [
          "14",
          "15",
          "16"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create EntryView.tsx component with route setup and basic layout structure",
            "description": "Initialize the EntryView page component at frontend/src/pages/EntryView.tsx and configure routing for /entries/:id path. Set up basic component structure with back button, metadata section placeholders, and content area containers.",
            "dependencies": [],
            "details": "Create frontend/src/pages/EntryView.tsx. Configure React Router route in App.tsx for /entries/:id. Implement useParams hook to extract entry ID from URL. Add back button navigation using useNavigate hook to return to dashboard. Create basic layout structure with semantic HTML sections for metadata, content, media gallery, and action buttons. Add Glass spec reference in component header comments.",
            "status": "pending",
            "testStrategy": "Verify route navigation from dashboard to /entries/:id works. Test back button returns to dashboard. Confirm entry ID is correctly extracted from URL params. Test on mobile viewport for responsive layout.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement entry data fetching with media attachments on component mount",
            "description": "Fetch complete entry data including metadata, raw content, polished content, tags, mood, and all media attachments (photos, audio, video) from GET /api/entries/:id endpoint when component mounts.",
            "dependencies": [
              1
            ],
            "details": "Use React useEffect hook to fetch entry data on mount. Call GET /api/entries/:id using authenticated API client. Implement loading state with spinner/skeleton. Handle error states (404 not found, 403 forbidden, network errors) with user-friendly messages. Store fetched entry data in component state including metadata (createdAt, source, userId), content (raw, polished), tags array, mood, and media attachments array with URLs and types. Add retry logic for failed requests.",
            "status": "pending",
            "testStrategy": "Mock API responses for entries with different media types. Test loading state displays correctly. Verify error handling for 404 and network failures. Test with entries containing no media, only photos, only audio, only video, and mixed media.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Display entry metadata including date, time, and source badge",
            "description": "Render entry metadata section showing formatted creation date, time, and source indicator badge (SMS or Web) with appropriate styling and icons.",
            "dependencies": [
              2
            ],
            "details": "Format createdAt timestamp using date-fns or similar library to display human-readable date and time (e.g., 'January 15, 2026 at 2:30 PM'). Create source badge component that displays 'SMS' or 'Web' with distinct colors and icons. Position metadata section prominently below back button. Add relative time display (e.g., '2 hours ago') alongside absolute time. Ensure timestamp handles timezone correctly. Style badges with rounded corners and subtle background colors.",
            "status": "pending",
            "testStrategy": "Test date formatting with various timestamps. Verify timezone handling. Test source badge displays correctly for both SMS and Web entries. Verify relative time updates. Test responsive layout on mobile.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Render polished content with markdown formatting support",
            "description": "Display the polished entry content with full markdown rendering support including headings, lists, links, emphasis, and paragraph breaks.",
            "dependencies": [
              2
            ],
            "details": "Install and configure react-markdown or marked library for markdown parsing. Create content display area that renders entry.polishedContent with markdown support. Configure markdown renderer to support: paragraphs, headings (h1-h6), bold/italic/strikethrough, unordered/ordered lists, links (sanitized), blockquotes, and code blocks. Apply appropriate CSS styling for readable typography with good line-height and spacing. Sanitize markdown output to prevent XSS attacks. Add prose styling for optimal readability.",
            "status": "pending",
            "testStrategy": "Test rendering with various markdown features: headings, lists, emphasis, links, blockquotes. Verify XSS protection by testing with malicious HTML/script tags. Test long-form content with multiple paragraphs. Verify typography and spacing on mobile and desktop.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement 'View Original' toggle with side-by-side or replace view",
            "description": "Add toggle button to switch between polished and original content views, supporting both side-by-side comparison and replace modes with smooth transitions.",
            "dependencies": [
              4
            ],
            "details": "Add 'View Original' toggle button/switch component below metadata section. Implement state management (useState) for toggle state. Create two view modes: (1) side-by-side layout showing polished on left and raw on right in two columns, (2) replace mode that swaps polished content with raw content in single column. Add smooth CSS transitions when toggling. Display raw content in preformatted text or plain textarea to show exactly as entered. Add visual indicator showing which version is currently displayed. Persist toggle preference in sessionStorage.",
            "status": "pending",
            "testStrategy": "Test toggle switches between polished and original content. Verify side-by-side layout on desktop and replace mode on mobile. Test transition animations are smooth. Verify raw content preserves formatting including line breaks and whitespace. Test toggle state persists across component re-renders.",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Create photo gallery with grid layout and lightbox functionality",
            "description": "Build responsive photo grid gallery for image attachments with click-to-expand lightbox overlay for full-size viewing.",
            "dependencies": [
              2
            ],
            "details": "Filter media attachments for image types (image/jpeg, image/png, image/gif, image/webp). Create responsive CSS grid layout (3 columns on desktop, 2 on tablet, 1 on mobile) displaying photo thumbnails. Implement lightbox component using react-image-lightbox or custom modal with: full-size image display, prev/next navigation arrows, close button (X and ESC key), swipe gestures on mobile, image counter (e.g., '2 of 5'), zoom functionality. Lazy load images using loading='lazy' attribute. Add loading skeletons for images. Handle missing/broken images gracefully with placeholder.",
            "status": "pending",
            "testStrategy": "Test grid layout responsiveness on different screen sizes. Verify lightbox opens on image click. Test navigation between images with arrows and keyboard. Test swipe gestures on touch devices. Verify ESC key closes lightbox. Test with entries having 0, 1, and multiple photos. Test lazy loading behavior.",
            "parentId": "undefined"
          },
          {
            "id": 7,
            "title": "Implement custom audio player with waveform visualization and controls",
            "description": "Build custom audio player component with waveform visualization, play/pause, seek controls, duration display, and playback progress using Wavesurfer.js or Howler.js.",
            "dependencies": [
              2
            ],
            "details": "Install Wavesurfer.js library for audio visualization. Create AudioPlayer component that accepts audio URL prop. Initialize Wavesurfer instance with waveform container, configure colors (waveColor, progressColor), set responsive height. Implement controls: play/pause button with icon toggle, seek bar synced with waveform clicks, current time / total duration display (mm:ss format), playback speed selector (0.5x, 1x, 1.5x, 2x), volume control slider. Add loading state while audio loads. Handle playback errors gracefully. Cleanup Wavesurfer instance on unmount. Style player with modern UI matching app theme.",
            "status": "pending",
            "testStrategy": "Test audio playback with various audio formats (mp3, wav, m4a). Verify waveform renders correctly. Test play/pause functionality. Test seeking by clicking waveform and using seek bar. Verify time displays update correctly. Test playback speed changes. Test volume control. Verify cleanup on component unmount prevents memory leaks.",
            "parentId": "undefined"
          },
          {
            "id": 8,
            "title": "Implement HTML5 video player with lazy loading and standard controls",
            "description": "Create video player component using native HTML5 video element with controls, lazy loading, and fallback for unsupported formats.",
            "dependencies": [
              2
            ],
            "details": "Filter media attachments for video types (video/mp4, video/webm, video/quicktime). Create VideoPlayer component using HTML5 <video> element with controls attribute enabled. Implement lazy loading using loading='lazy' or Intersection Observer to defer video load until scrolled into view. Add poster image (thumbnail if available). Configure video attributes: controls, preload='metadata', playsinline for mobile. Provide multiple source formats if available for browser compatibility. Add custom styling to video container with max-width constraints. Display video dimensions and file size. Handle video loading errors with fallback message. Add fullscreen capability.",
            "status": "pending",
            "testStrategy": "Test video playback with different formats (mp4, webm). Verify lazy loading defers load until viewport intersection. Test native controls (play/pause, seek, volume, fullscreen). Test on mobile with playsinline. Verify error handling for corrupted or unavailable videos. Test responsive sizing on different screen sizes.",
            "parentId": "undefined"
          },
          {
            "id": 9,
            "title": "Display transcripts below audio and video players",
            "description": "Show transcription text below audio and video media players when transcripts are available, with expandable/collapsible functionality for long transcripts.",
            "dependencies": [
              7,
              8
            ],
            "details": "Check media attachment objects for transcript property. If transcript exists, render transcript section below corresponding audio/video player. Implement expandable component: show first 3 lines with 'Show more' button for long transcripts, 'Show less' to collapse. Format transcript with proper paragraph breaks and timestamps if available. Add subtle styling (lighter text, smaller font, indented) to distinguish from main content. Add copy-to-clipboard button for full transcript. Handle missing or empty transcripts gracefully (don't show section). Support transcript search/highlight if transcript is long.",
            "status": "pending",
            "testStrategy": "Test transcript display for audio with transcripts. Test transcript display for video with transcripts. Verify expand/collapse functionality. Test copy-to-clipboard button. Test media without transcripts don't show transcript section. Test long transcripts are properly truncated initially.",
            "parentId": "undefined"
          },
          {
            "id": 10,
            "title": "Build inline edit functionality with form validation and save persistence",
            "description": "Implement inline editing mode for polished content, tags, and mood with form validation and PUT request to /api/entries/:id endpoint to persist changes.",
            "dependencies": [
              4,
              3
            ],
            "details": "Add 'Edit' button that toggles edit mode state. In edit mode: replace markdown display with textarea for polished content editing (not raw content), render tag input component allowing add/remove tags with autocomplete, add mood selector dropdown/buttons. Implement form state management with React useState or useForm hook. Add validation: content cannot be empty, tags must be valid format, mood must be from allowed values. Add Save and Cancel buttons. On Save: call PUT /api/entries/:id with updated fields, show loading state, handle success (update local state and exit edit mode) and error responses (display error message), optimistic UI update. On Cancel: revert to original values and exit edit mode.",
            "status": "pending",
            "testStrategy": "Test edit button toggles edit mode. Verify textarea displays current polished content. Test tag addition and removal. Test mood selection. Verify validation prevents saving empty content. Test save success updates display. Test save error displays message. Test cancel reverts changes. Test optimistic updates.",
            "parentId": "undefined"
          },
          {
            "id": 11,
            "title": "Add delete button with confirmation modal and API integration",
            "description": "Implement delete functionality with confirmation modal dialog to prevent accidental deletion, calling DELETE /api/entries/:id and redirecting to dashboard on success.",
            "dependencies": [
              1
            ],
            "details": "Add 'Delete' button with danger styling (red color) in actions section. Create confirmation modal component that appears on delete click with: warning message 'Are you sure you want to delete this entry? This cannot be undone.', Cancel button (secondary style), Confirm Delete button (danger style). Implement modal state management (open/close). On confirm: call DELETE /api/entries/:id with authenticated request, show loading state in modal, on success: close modal, show success toast/notification, navigate to dashboard using useNavigate, on error: display error message in modal, keep modal open. Add keyboard support (ESC to cancel, Enter to confirm). Prevent accidental clicks with short delay or double confirmation for extra safety.",
            "status": "pending",
            "testStrategy": "Test delete button opens confirmation modal. Verify modal displays warning message. Test cancel button closes modal without deleting. Test confirm button calls DELETE API. Verify successful deletion redirects to dashboard. Test error handling displays error message. Test ESC key closes modal. Verify modal prevents background interaction.",
            "parentId": "undefined"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 11,
        "expansionPrompt": "Break down entry detail view into: (1) create EntryView.tsx for route /entries/:id, (2) fetch entry data with media attachments on mount, (3) implement back button navigation, (4) display entry metadata (date, time, source badge), (5) render polished content with markdown, (6) implement 'View Original' toggle (side-by-side or replace view), (7) create photo gallery with grid layout and lightbox on click, (8) implement custom audio player with play/pause/seek controls and waveform (Howler.js or Wavesurfer.js), (9) implement HTML5 video player with controls, (10) display transcripts below audio/video players, (11) implement inline edit functionality (PUT /api/entries/:id), add delete button with confirmation modal, create Glass spec for frontend/entry-view.glass"
      },
      {
        "id": "19",
        "title": "Implement data export API with JSON and PDF formats",
        "description": "Build export functionality that generates downloadable archives of user's journal data in JSON format and print-ready PDF format with all entries and media references.",
        "details": "Create `src/routes/api/export.ts` with endpoints:\n\n**GET /api/export/json**\n- Query all entries, media, reminders for user\n- Generate JSON structure:\n```json\n{\n  \"user\": { \"email\", \"displayName\", \"exportDate\" },\n  \"entries\": [\n    {\n      \"id\", \"entryDate\", \"rawContent\", \"polishedContent\",\n      \"type\", \"source\", \"mood\", \"tags\", \"location\",\n      \"media\": [{ \"id\", \"type\", \"url\", \"transcription\" }]\n    }\n  ],\n  \"stats\": { \"totalEntries\", \"firstEntry\", \"lastEntry\" }\n}\n```\n- Set Content-Disposition header for download\n- Filename: `journalizer-export-{userId}-{date}.json`\n\n**GET /api/export/pdf** (query params: startDate?, endDate?)\n- Use pdf-lib or Puppeteer (via Browserless worker) to generate PDF\n- Template:\n  - Cover page: \"Journal of {displayName}\" with date range\n  - Table of contents with page numbers\n  - Entries: One per page or continuous, with date headers, polished content, media thumbnails (embedded), mood icons\n  - Footer: Page numbers, \"Generated by Journalizer\"\n- For media: Embed thumbnails, include \"[Audio/Video recording attached]\" placeholders\n- Filename: `journalizer-{startDate}-{endDate}.pdf`\n\nGlass spec:\n- `glass/routes/export.glass` - Intent: portable data export; Contract: guarantees complete data inclusion, media reference accuracy, PDF formatting consistency, GDPR compliance",
        "testStrategy": "Test JSON export with various entry counts. Verify JSON structure is valid and includes all data. Test PDF generation with text-only entries and entries with media. Test date range filtering for PDF. Verify downloads work in all browsers. Test with large datasets (100+ entries).",
        "priority": "medium",
        "dependencies": [
          "8"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement GET /api/export/json endpoint with authentication",
            "description": "Create the JSON export endpoint in src/routes/api/export.ts with user authentication middleware and basic route structure.",
            "dependencies": [],
            "details": "Set up the export.ts route file with GET /api/export/json endpoint. Add authentication middleware to verify JWT session and extract userId. Create the basic handler function that will orchestrate the JSON export process. Include proper error handling for unauthenticated requests. Return 401 if no valid session exists.",
            "status": "pending",
            "testStrategy": "Test with valid and invalid JWT tokens. Verify 401 response for unauthenticated requests. Confirm authenticated requests reach the handler.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Query all entries, media, and reminders for user from D1",
            "description": "Implement database queries to fetch all user's journal entries with associated media attachments and reminder configurations from D1.",
            "dependencies": [
              1
            ],
            "details": "Write D1 queries to fetch: (1) all entries for userId with SELECT from journal_entries, (2) all media for those entries with JOIN or separate query to media_files, (3) all reminders with SELECT from reminders. Use prepared statements for security. Handle pagination or streaming for large datasets (100+ entries). Consider memory limits in Cloudflare Workers (128MB default). Order entries by entryDate descending.",
            "status": "pending",
            "testStrategy": "Test with users having 0, 1, 10, and 100+ entries. Verify all related media and reminders are fetched. Test query performance with large datasets. Confirm no memory issues in Workers environment.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Construct JSON export structure with user info and statistics",
            "description": "Build the complete JSON export object including user metadata, entries with nested media, and calculated statistics.",
            "dependencies": [
              2
            ],
            "details": "Transform database results into the specified JSON structure: { user: { email, displayName, exportDate: new Date().toISOString() }, entries: [...], stats: { totalEntries, firstEntry, lastEntry } }. For each entry, include: id, entryDate, rawContent, polishedContent, type, source, mood, tags, location, and nested media array with { id, type, url, transcription }. Calculate stats from entry data. Ensure all fields are present even if null. Format dates consistently as ISO 8601 strings.",
            "status": "pending",
            "testStrategy": "Verify JSON structure matches specification exactly. Test with entries having various field combinations (with/without media, tags, location). Validate stats calculations are accurate. Confirm JSON.stringify produces valid output.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Set Content-Disposition header and return JSON download",
            "description": "Configure response headers for file download and return the JSON export with appropriate filename.",
            "dependencies": [
              3
            ],
            "details": "Generate filename using pattern: journalizer-export-{userId}-{YYYY-MM-DD}.json. Set response headers: Content-Type: application/json, Content-Disposition: attachment; filename=\"{filename}\". Return JSON string as response body. Ensure proper character encoding (UTF-8). Handle large JSON responses that may approach Worker response size limits.",
            "status": "pending",
            "testStrategy": "Test download triggers in various browsers (Chrome, Firefox, Safari). Verify filename format is correct. Confirm Content-Type and Content-Disposition headers are set properly. Test with large exports (100+ entries).",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement GET /api/export/pdf endpoint with date range query params",
            "description": "Create PDF export endpoint with optional startDate and endDate query parameters for filtering entries.",
            "dependencies": [
              1
            ],
            "details": "Add GET /api/export/pdf route to export.ts with authentication middleware. Parse query params: startDate (ISO date string), endDate (ISO date string), both optional. Validate date formats and ensure startDate <= endDate. If no dates provided, export all entries. Query D1 for entries filtered by date range: WHERE entryDate >= startDate AND entryDate <= endDate. Include associated media for filtered entries.",
            "status": "pending",
            "testStrategy": "Test with no date params (all entries), only startDate, only endDate, and both params. Verify invalid date formats return 400 error. Test startDate > endDate returns validation error. Confirm correct entries are filtered.",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Integrate pdf-lib for PDF generation in Workers environment",
            "description": "Set up pdf-lib library for PDF document creation compatible with Cloudflare Workers runtime constraints.",
            "dependencies": [
              5
            ],
            "details": "Install pdf-lib package (pure JavaScript, works in Workers). Import PDFDocument, StandardFonts, rgb from pdf-lib. Create basic PDF generation function that initializes a PDFDocument, adds pages, and returns PDF bytes. Handle Workers memory constraints (128MB). Consider alternative: If pdf-lib limitations arise, prepare integration point for external Browserless service (Cloudflare Worker can make fetch requests to Browserless API). Test basic PDF creation works in Workers environment.",
            "status": "pending",
            "testStrategy": "Test pdf-lib imports and basic PDF creation in Workers. Verify generated PDF bytes are valid. Test with small document first. Monitor memory usage. If pdf-lib fails, document Browserless integration approach.",
            "parentId": "undefined"
          },
          {
            "id": 7,
            "title": "Design and implement PDF template structure",
            "description": "Create PDF template with cover page, table of contents, entry pages with headers, and footer with page numbers.",
            "dependencies": [
              6
            ],
            "details": "Implement PDF layout: (1) Cover page - title 'Journal of {displayName}', subtitle with date range '{startDate} - {endDate}', centered text with large font. (2) Table of Contents page - list entry dates and page numbers (calculate after layout). (3) Entry pages - each entry with date header (bold, 16pt), polished content (body text, 12pt), mood icon representation (text emoji), tags list, location if present. (4) Footer on every page except cover: 'Generated by Journalizer' (left), page number (right). Use pdf-lib page.drawText() with proper positioning, fonts (Helvetica, Times-Roman), and spacing.",
            "status": "pending",
            "testStrategy": "Verify cover page displays correctly with user data. Test TOC generation with 5, 10, 50 entries. Confirm entry pages have proper formatting and spacing. Verify footer appears on all pages except cover. Test PDF opens in Adobe Reader and browser viewers.",
            "parentId": "undefined"
          },
          {
            "id": 8,
            "title": "Embed media thumbnails in PDF from R2 storage",
            "description": "Fetch media thumbnails from R2 and embed them as images in PDF entry pages using pdf-lib image embedding.",
            "dependencies": [
              7
            ],
            "details": "For each entry with media: (1) Fetch thumbnail from R2 using media.url (or generate thumbnail URL pattern). (2) Download image bytes using fetch(). (3) Embed in PDF using pdfDoc.embedJpg() or embedPng() based on media type. (4) Draw image on page using page.drawImage() with dimensions (max 200x200px to fit layout). (5) Position thumbnail below entry text. Handle errors gracefully if media fetch fails (skip image, continue PDF generation). Add '[Image]' text placeholder if embedding fails. Consider memory limits - may need to process images in batches.",
            "status": "pending",
            "testStrategy": "Test entries with photos (JPEG, PNG). Verify thumbnails appear in correct position on PDF page. Test with multiple images per entry. Verify PDF generation continues if image fetch fails. Test memory usage with 20+ images.",
            "parentId": "undefined"
          },
          {
            "id": 9,
            "title": "Add audio/video placeholders in PDF for non-embeddable media",
            "description": "Insert text placeholders for audio and video media that cannot be embedded directly in PDF documents.",
            "dependencies": [
              8
            ],
            "details": "For media with type 'audio' or 'video': Insert text placeholder below entry content using page.drawText(): '[Audio recording attached: {filename}]' or '[Video recording attached: {filename}]'. Include media duration if available in metadata. Add hyperlink text (non-clickable) showing media URL for reference. Style placeholder with italic font or gray color to distinguish from body text. Position consistently with image thumbnails. Include transcription text below placeholder if transcription field is populated.",
            "status": "pending",
            "testStrategy": "Test entries with audio files show correct placeholder text. Test video entries show video placeholder. Verify transcription text appears when available. Confirm placeholder formatting is visually distinct from body text.",
            "parentId": "undefined"
          },
          {
            "id": 10,
            "title": "Create Glass spec for routes/export.glass with data completeness contract",
            "description": "Write Glass specification documenting export API intent, contracts for data completeness, GDPR compliance, and format accuracy.",
            "dependencies": [
              4,
              9
            ],
            "details": "Create glass/routes/export.glass file following GLASS.md conventions. Document: Intent - 'Provide portable data export in JSON and PDF formats for user data ownership and GDPR compliance'. Contract - 'Guarantees: (1) Complete data inclusion - all entries, media references, reminders exported without omission, (2) Media reference accuracy - all media URLs are valid and accessible, (3) PDF formatting consistency - readable layout across viewers, proper pagination, (4) GDPR compliance - exports contain all personal data, enable data portability right'. Include examples for both endpoints. Document error conditions and edge cases (empty export, large datasets, missing media).",
            "status": "pending",
            "testStrategy": "Verify Glass spec follows project conventions in GLASS.md. Review contract guarantees cover all export requirements. Confirm examples are accurate. Validate spec is committed to repository.",
            "parentId": "undefined"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 10,
        "expansionPrompt": "Break down export API into: (1) implement GET /api/export/json endpoint, (2) query all entries, media, reminders for user from D1, (3) construct JSON export structure with user info and stats, (4) set Content-Disposition header for download, (5) implement GET /api/export/pdf endpoint with date range query params, (6) integrate pdf-lib or Puppeteer (via Browserless) for PDF generation, (7) design PDF template (cover page, TOC, entry pages with dates), (8) embed media thumbnails in PDF, (9) add placeholders for audio/video, (10) create Glass spec for routes/export.glass with completeness contract"
      },
      {
        "id": "20",
        "title": "Set up GitHub Actions CI/CD pipeline for testing and deployment",
        "description": "Configure automated CI/CD pipeline using GitHub Actions for linting, type checking, testing, and deploying to Cloudflare Workers on push to main branch.",
        "details": "Create `.github/workflows/deploy.yml`:\n\n```yaml\nname: Deploy to Cloudflare\n\non:\n  push:\n    branches: [main]\n  pull_request:\n    branches: [main]\n\njobs:\n  lint-and-test:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - uses: actions/setup-node@v3\n        with:\n          node-version: '20'\n      - run: npm ci\n      - run: npm run lint\n      - run: npm run typecheck\n      - run: npm test\n  \n  deploy:\n    needs: lint-and-test\n    runs-on: ubuntu-latest\n    if: github.ref == 'refs/heads/main'\n    steps:\n      - uses: actions/checkout@v3\n      - uses: actions/setup-node@v3\n        with:\n          node-version: '20'\n      - run: npm ci\n      - run: npm run build\n      - uses: cloudflare/wrangler-action@v3\n        with:\n          apiToken: ${{ secrets.CLOUDFLARE_API_TOKEN }}\n          accountId: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}\n```\n\nAdd npm scripts to package.json:\n- `lint`: ESLint on src/\n- `typecheck`: tsc --noEmit\n- `test`: Vitest unit tests\n- `build`: Vite build + glass compile\n- `deploy`: wrangler deploy\n\nSet up Cloudflare API token as GitHub Secret. Configure D1 migrations to run in deployment.\n\nGlass spec:\n- `glass/ci/pipeline.glass` - Intent: automated testing and deployment; Contract: guarantees test execution before deploy, deployment atomicity, rollback capability, secret security",
        "testStrategy": "Push to main and verify workflow runs. Test that failing tests block deployment. Test that secrets are properly masked in logs. Verify deployment succeeds and worker is accessible. Test PR builds run tests but don't deploy.",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create .github/workflows/deploy.yml with basic job structure",
            "description": "Set up the GitHub Actions workflow file with the overall structure including triggers (push to main, pull requests) and define the two main jobs: lint-and-test and deploy with proper dependencies.",
            "dependencies": [],
            "details": "Create `.github/workflows/deploy.yml` with workflow name 'Deploy to Cloudflare', configure triggers for push to main and pull_request events, define two jobs: 'lint-and-test' and 'deploy' where deploy needs lint-and-test and only runs on main branch (if: github.ref == 'refs/heads/main'). Use ubuntu-latest runners and Node.js 20.",
            "status": "pending",
            "testStrategy": "Verify YAML syntax is valid. Push to a test branch and confirm workflow appears in GitHub Actions UI. Check that job dependencies are correctly configured.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Configure lint job with ESLint and add npm lint script",
            "description": "Add ESLint configuration and create the npm run lint script in package.json, then add the lint step to the lint-and-test job in the GitHub Actions workflow.",
            "dependencies": [
              1
            ],
            "details": "Add 'lint' script to package.json that runs ESLint on src/ directory. Configure ESLint with TypeScript support if not already present. Add 'npm run lint' step to the lint-and-test job after npm ci. Ensure ESLint configuration catches common issues and enforces code style.",
            "status": "pending",
            "testStrategy": "Run npm run lint locally and verify it scans all source files. Intentionally introduce a linting error and verify the workflow fails on that step.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Add typecheck step using tsc --noEmit and npm script",
            "description": "Create npm run typecheck script that runs TypeScript compiler in check-only mode, and add this step to the lint-and-test job to catch type errors before deployment.",
            "dependencies": [
              1
            ],
            "details": "Add 'typecheck' script to package.json running 'tsc --noEmit' to validate TypeScript without emitting files. Ensure tsconfig.json is properly configured for strict mode. Add 'npm run typecheck' step to lint-and-test job after the lint step.",
            "status": "pending",
            "testStrategy": "Run npm run typecheck locally and verify it completes successfully. Introduce a type error and confirm the workflow fails. Verify no output files are generated.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Configure test job with Vitest and npm test script",
            "description": "Set up Vitest testing framework, create npm run test script, and add the test execution step to the lint-and-test job in the workflow.",
            "dependencies": [
              1
            ],
            "details": "Install Vitest if not present. Add 'test' script to package.json running Vitest unit tests. Configure Vitest for the project structure. Add 'npm test' step to lint-and-test job after typecheck. Ensure tests run in CI mode without watch.",
            "status": "pending",
            "testStrategy": "Run npm test locally and verify all tests pass. Create a failing test and confirm the workflow fails at the test step, blocking deployment. Verify test coverage reporting works.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Add build and deploy npm scripts with Glass compilation",
            "description": "Create npm scripts for building the project (including Glass compilation) and deploying with Wrangler, preparing for the deployment job configuration.",
            "dependencies": [],
            "details": "Add 'build' script to package.json that runs Vite build followed by Glass compile command. Add 'deploy' script running 'wrangler deploy'. Ensure build output is properly configured for Cloudflare Workers. Verify Glass specs compile correctly as part of build process.",
            "status": "pending",
            "testStrategy": "Run npm run build locally and verify all assets are generated including Glass artifacts. Test npm run deploy with local Wrangler credentials to ensure deployment works.",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Configure deploy job with Cloudflare Wrangler action",
            "description": "Set up the deploy job in the workflow with Cloudflare Wrangler GitHub Action, using secrets for authentication and including the build step before deployment.",
            "dependencies": [
              5
            ],
            "details": "In the deploy job, add checkout, setup-node, npm ci, and npm run build steps. Add cloudflare/wrangler-action@v3 step using apiToken and accountId from GitHub Secrets. Configure to use CLOUDFLARE_API_TOKEN and CLOUDFLARE_ACCOUNT_ID secrets. Add D1 migration execution as part of deployment (wrangler d1 migrations apply).",
            "status": "pending",
            "testStrategy": "Verify workflow syntax for deploy job. After secrets are configured, push to main and confirm deployment executes. Check Cloudflare dashboard for successful worker deployment. Verify D1 migrations run correctly.",
            "parentId": "undefined"
          },
          {
            "id": 7,
            "title": "Set up GitHub Secrets for Cloudflare API credentials",
            "description": "Create and configure CLOUDFLARE_API_TOKEN and CLOUDFLARE_ACCOUNT_ID as GitHub repository secrets for secure authentication during deployment.",
            "dependencies": [],
            "details": "Generate Cloudflare API token with Workers deployment permissions from Cloudflare dashboard. Obtain Cloudflare Account ID from dashboard. Add both as GitHub Secrets in repository settings: CLOUDFLARE_API_TOKEN and CLOUDFLARE_ACCOUNT_ID. Document the required permissions for the API token. Verify secrets are properly masked in workflow logs.",
            "status": "pending",
            "testStrategy": "Push to main branch after configuration and verify deployment authenticates successfully. Check workflow logs to confirm secrets are masked (not displayed). Test that deployment fails with invalid/missing secrets.",
            "parentId": "undefined"
          }
        ],
        "complexity": 4,
        "recommendedSubtasks": 7,
        "expansionPrompt": "Break down CI/CD pipeline into: (1) create .github/workflows/deploy.yml with job structure, (2) configure lint-and-test job with ESLint, (3) add typecheck step using tsc --noEmit, (4) add test step using Vitest, (5) configure deploy job dependent on lint-and-test, (6) add Cloudflare Wrangler deployment step, (7) configure GitHub Secrets for CLOUDFLARE_API_TOKEN and CLOUDFLARE_ACCOUNT_ID, add npm scripts (lint, typecheck, test, build, deploy), configure D1 migrations in deployment"
      },
      {
        "id": "21",
        "title": "Implement comprehensive error handling and logging system",
        "description": "Build centralized error handling, structured logging, and monitoring integration for debugging, tracking API failures, and monitoring Worker performance.",
        "details": "Create `src/lib/logger.ts` with logging utilities:\n\n```typescript\ninterface LogContext {\n  userId?: string;\n  requestId: string;\n  endpoint: string;\n  duration?: number;\n  error?: Error;\n  metadata?: Record<string, any>;\n}\n\nfunction log(level: 'info' | 'warn' | 'error', message: string, context: LogContext)\n```\n\nIntegrate with:\n- Cloudflare Workers Analytics Engine for custom metrics\n- Sentry or Axiom for error tracking (optional Phase 2)\n- processing_log table for AI/transcription operation tracking\n\n**Error handling patterns:**\n- API errors: Return structured JSON { error: { code, message, details } }\n- Use error codes: AUTH_FAILED, VALIDATION_ERROR, MEDIA_PROCESSING_FAILED, RATE_LIMIT_EXCEEDED, etc.\n- Never expose internal errors (stack traces) to clients\n- Log all errors with context (userId, endpoint, input parameters)\n\n**Monitoring:**\n- Track key metrics: API latency, AI processing time, transcription duration, SMS delivery rate\n- Alert on: High error rates, slow responses (>2s), Twilio failures, API quota exhaustion\n\n**Rate limiting:**\n- Use KV for rate limit counters: `rate-limit:{userId}:{endpoint}`\n- Limits: 100 requests/hour per user for entry creation, 10/hour for phone verification\n\nGlass spec:\n- `glass/lib/error-handling.glass` - Intent: reliable error tracking and debugging; Contract: guarantees structured error responses, PII protection in logs, metric collection, rate limit enforcement",
        "testStrategy": "Test all error scenarios (auth failure, validation error, API timeout, etc.). Verify error responses have correct structure. Test rate limiting blocks excess requests. Verify logs are structured and searchable. Test that sensitive data (passwords, tokens) is never logged.",
        "priority": "high",
        "dependencies": [
          "4"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create logger.ts with structured logging utilities",
            "description": "Create src/lib/logger.ts file with core logging infrastructure including the log function and LogContext interface",
            "dependencies": [],
            "details": "Create src/lib/logger.ts with:\n- LogContext interface with fields: userId (optional), requestId, endpoint, duration (optional), error (optional), metadata (optional)\n- log function signature: log(level: 'info' | 'warn' | 'error', message: string, context: LogContext)\n- Basic implementation that formats logs as structured JSON\n- Ensure all logs include timestamp, level, message, and context fields",
            "status": "pending",
            "testStrategy": "Test log function with different levels (info, warn, error). Verify output format is valid JSON. Test with minimal and complete LogContext objects. Verify timestamps are included in ISO format.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement PII filtering in logs",
            "description": "Add PII protection layer to logger to prevent sensitive data from being logged",
            "dependencies": [
              1
            ],
            "details": "Enhance logger.ts with PII filtering:\n- Create sanitize function that removes/redacts sensitive fields from context and metadata\n- Filter patterns: passwords, tokens, auth headers, credit cards, SSNs, API keys\n- Use allowlist approach for metadata fields to ensure unknown fields don't leak PII\n- Redact sensitive parts of phone numbers and emails (show format but mask digits)\n- Apply sanitization before logging at all levels",
            "status": "pending",
            "testStrategy": "Test that passwords, tokens, and auth headers are never logged. Verify phone numbers and emails are properly redacted. Test metadata sanitization removes unknown sensitive fields. Verify allowlisted fields pass through unchanged.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Define error codes and structured error response types",
            "description": "Create standardized error code constants and error response structure for consistent API error handling",
            "dependencies": [],
            "details": "Create error types and codes in src/lib/logger.ts or src/lib/errors.ts:\n- Define ErrorCode enum with values: AUTH_FAILED, VALIDATION_ERROR, MEDIA_PROCESSING_FAILED, RATE_LIMIT_EXCEEDED, NOT_FOUND, INTERNAL_ERROR, EXTERNAL_API_FAILED, QUOTA_EXCEEDED\n- Create ErrorResponse interface: { error: { code: ErrorCode, message: string, details?: Record<string, any> } }\n- Create helper function createErrorResponse(code, message, details?) that returns properly structured response\n- Ensure stack traces and internal errors are never exposed in details",
            "status": "pending",
            "testStrategy": "Verify all error codes are defined. Test createErrorResponse returns correct structure. Verify stack traces are never included in error responses. Test that details field properly sanitizes internal error information.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement structured error response handler",
            "description": "Create middleware or utility to convert errors into standardized JSON responses",
            "dependencies": [
              2,
              3
            ],
            "details": "Create error handling utilities:\n- Implement handleError(error: Error, context: LogContext) function that logs error with sanitized context and returns structured ErrorResponse\n- Map common error types to appropriate error codes (auth errors -> AUTH_FAILED, validation -> VALIDATION_ERROR)\n- Set appropriate HTTP status codes (401 for AUTH_FAILED, 400 for VALIDATION_ERROR, 429 for RATE_LIMIT_EXCEEDED, 500 for INTERNAL_ERROR)\n- Always log errors before returning response\n- Include requestId in error response for tracing",
            "status": "pending",
            "testStrategy": "Test error handler with different error types. Verify correct HTTP status codes. Verify errors are logged with proper context. Test that requestId is included in responses. Verify internal errors return generic INTERNAL_ERROR without exposing details.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Integrate Cloudflare Workers Analytics Engine",
            "description": "Set up Workers Analytics Engine bindings and create metric tracking utilities",
            "dependencies": [
              1
            ],
            "details": "Configure Analytics Engine integration:\n- Add Analytics Engine binding to wrangler.toml (name: ANALYTICS)\n- Create writeMetric(name: string, value: number, context: Record<string, string>) utility\n- Define metric names: api_latency, ai_processing_time, transcription_duration, sms_delivery_success, sms_delivery_failure\n- Include dimensions in context: endpoint, userId, status_code, error_code\n- Call writeMetric in log function for relevant events\n- Ensure metric writes don't block request processing (fire-and-forget)",
            "status": "pending",
            "testStrategy": "Verify Analytics Engine binding is configured in wrangler.toml. Test writeMetric function writes to Analytics Engine. Verify metrics include proper dimensions. Test that metric write failures don't crash requests. Query Analytics Engine to verify data is recorded.",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Track key performance metrics",
            "description": "Implement automatic tracking of API latency, AI processing time, transcription duration, and SMS delivery rates",
            "dependencies": [
              5
            ],
            "details": "Add metric tracking throughout application:\n- Track api_latency: measure request start to end, log with endpoint and status_code dimensions\n- Track ai_processing_time: measure AI analysis duration in journal entry processing\n- Track transcription_duration: measure time for Whisper API calls\n- Track sms_delivery_success and sms_delivery_failure: track Twilio send outcomes\n- Use performance.now() for timing measurements\n- Include userId dimension for per-user analysis\n- Log metrics at 'info' level with duration in context",
            "status": "pending",
            "testStrategy": "Test that api_latency is tracked for all endpoints. Verify AI processing time is measured correctly. Test transcription duration tracking with mock Whisper calls. Verify SMS delivery metrics track success/failure. Check all metrics include required dimensions.",
            "parentId": "undefined"
          },
          {
            "id": 7,
            "title": "Implement rate limiting using KV counters",
            "description": "Build rate limiting system using Cloudflare KV with configurable limits per endpoint and user",
            "dependencies": [
              3
            ],
            "details": "Create src/lib/rate-limit.ts:\n- Implement checkRateLimit(userId: string, endpoint: string, limit: number, windowSeconds: number): Promise<boolean>\n- Use KV keys: rate-limit:{userId}:{endpoint}:{windowStart}\n- Store counter value and expiration (TTL = windowSeconds)\n- Limits: entry creation 100/hour (3600s), phone verification 10/hour\n- Return RATE_LIMIT_EXCEEDED error when limit exceeded\n- Include headers: X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Reset\n- Log rate limit violations with userId and endpoint",
            "status": "pending",
            "testStrategy": "Test rate limiting blocks after configured limit. Verify KV counters increment correctly. Test window expiration resets counters. Verify rate limit headers are correct. Test different limits for different endpoints. Verify RATE_LIMIT_EXCEEDED error is returned with proper structure.",
            "parentId": "undefined"
          },
          {
            "id": 8,
            "title": "Apply rate limiting to entry creation and phone verification endpoints",
            "description": "Integrate rate limiting middleware into API endpoints that require throttling",
            "dependencies": [
              7,
              4
            ],
            "details": "Add rate limiting to endpoints:\n- Apply to POST /api/entries (100 requests/hour per user)\n- Apply to POST /api/settings/verify-phone (10 requests/hour per user)\n- Call checkRateLimit before processing request\n- Return 429 status with RATE_LIMIT_EXCEEDED error if limit exceeded\n- Include rate limit headers in all responses\n- Log rate limit violations with full context (userId, endpoint, requestId)\n- Ensure rate limiting happens before expensive operations",
            "status": "pending",
            "testStrategy": "Test entry creation blocks after 100 requests in 1 hour. Test phone verification blocks after 10 requests in 1 hour. Verify 429 status code and error structure. Test rate limit headers are present. Verify rate limits are per-user (different users don't share counters).",
            "parentId": "undefined"
          },
          {
            "id": 9,
            "title": "Configure alerting for high error rates and slow responses",
            "description": "Set up monitoring alerts for critical performance and error conditions",
            "dependencies": [
              6
            ],
            "details": "Configure alerting strategy (implementation depends on monitoring tool):\n- Alert on error rate >5% over 5-minute window (group by endpoint)\n- Alert on API latency p95 >2000ms over 5-minute window\n- Alert on Twilio SMS failures >10% over 15-minute window\n- Alert on AI/transcription API quota exhaustion (track quota usage in metrics)\n- Document alert configuration in README or monitoring setup guide\n- Use Cloudflare Workers Analytics Engine for querying\n- Consider Cloudflare Workers notifications or external service (PagerDuty, Slack) for Phase 2",
            "status": "pending",
            "testStrategy": "Document alert thresholds and conditions. Verify Analytics Engine queries can detect alert conditions. Test alert queries with sample data showing high error rates. Test slow response detection with mock latency data. Create runbook for responding to alerts.",
            "parentId": "undefined"
          },
          {
            "id": 10,
            "title": "Integrate processing_log table for AI/transcription operations",
            "description": "Log all AI analysis and transcription operations to processing_log table for debugging and tracking",
            "dependencies": [
              1,
              2
            ],
            "details": "Enhance AI/transcription operations with logging:\n- Insert into processing_log table when starting AI/transcription operations (status=pending)\n- Update processing_log on completion (status=completed, error_message if failed)\n- Store operation_type (e.g., 'gemini_analysis', 'whisper_transcription')\n- Store input_data reference (journal_entry_id or media reference)\n- Store duration in processing_time_ms\n- Sanitize input_data and output_data to prevent PII logging\n- Log processing_log insertions/updates using logger with appropriate context",
            "status": "pending",
            "testStrategy": "Test processing_log entries are created for AI operations. Verify status transitions from pending to completed/failed. Test error messages are logged on failure. Verify PII is sanitized in logged data. Test duration tracking is accurate. Query processing_log to verify all operations are tracked.",
            "parentId": "undefined"
          },
          {
            "id": 11,
            "title": "Create Glass spec for lib/error-handling.glass",
            "description": "Document error handling system contract and intent in Glass framework format",
            "dependencies": [
              1,
              2,
              3,
              4,
              5,
              7,
              10
            ],
            "details": "Create glass/lib/error-handling.glass following Glass framework format:\n- Intent: Reliable error tracking and debugging for all API operations\n- Contract: Guarantees structured error responses (code, message, details), PII protection in all logs, metric collection for key operations, rate limit enforcement per endpoint/user\n- Inputs: Errors from any application layer, log contexts from request handlers\n- Outputs: Structured JSON error responses, sanitized logs, metrics in Analytics Engine, rate limit decisions\n- Dependencies: Cloudflare KV (rate limiting), Analytics Engine (metrics), D1 processing_log table\n- Document error codes, rate limits, PII filtering rules, and alerting thresholds",
            "status": "pending",
            "testStrategy": "Verify Glass spec matches GLASS.md format. Review spec covers all error codes, rate limits, and PII rules. Validate contract guarantees are testable. Ensure dependencies section lists all external services. Peer review Glass spec for completeness.",
            "parentId": "undefined"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 11,
        "expansionPrompt": "Break down error handling into: (1) create logger.ts with structured logging utilities, (2) define LogContext interface with userId, requestId, endpoint, duration, error, metadata, (3) implement log function for info/warn/error levels, (4) integrate Cloudflare Workers Analytics Engine for custom metrics, (5) implement structured error responses (code, message, details), (6) define error codes (AUTH_FAILED, VALIDATION_ERROR, MEDIA_PROCESSING_FAILED, RATE_LIMIT_EXCEEDED, etc.), (7) implement PII filtering in logs, (8) implement rate limiting using KV counters (100 req/hr for entries, 10/hr for phone verification), (9) track key metrics (API latency, AI processing time, transcription duration, SMS delivery rate), (10) configure alerts for high error rates and slow responses, (11) create Glass spec for lib/error-handling.glass"
      },
      {
        "id": "22",
        "title": "Write comprehensive test suite with unit and integration tests",
        "description": "Develop complete test coverage using Vitest for unit tests and Playwright for end-to-end tests, covering all API endpoints, services, and critical user flows.",
        "details": "Set up testing infrastructure:\n\n**Unit tests** (Vitest):\n- Install vitest, @cloudflare/workers-types\n- Create `tests/unit/` directory structure mirroring src/\n- Test coverage goals:\n  - `src/db/queries.ts`: All CRUD operations with mock D1\n  - `src/services/ai.ts`: AI polish with mocked Anthropic API\n  - `src/services/transcription.ts`: Transcription with mocked Deepgram\n  - `src/services/media.ts`: R2 upload/download with mocked R2\n  - `src/services/sms.ts`: SMS sending with mocked Twilio\n  - `src/lib/auth.ts`: JWT signing/verification\n  - `src/routes/`: All endpoints with mocked dependencies\n\n**Integration tests** (Wrangler + Vitest):\n- Test with real D1 (local or dev), R2, KV bindings\n- Test full request flows: login  create entry  list entries\n- Test webhook processing with mocked Twilio requests\n- Test cron trigger logic\n\n**E2E tests** (Playwright):\n- Test critical user flows:\n  1. Sign up with Google OAuth\n  2. Verify phone number\n  3. Create entry via web\n  4. Simulate SMS entry via webhook\n  5. Configure reminder\n  6. Export data\n\nTarget 80%+ code coverage. Run tests in CI.\n\nGlass specs for each test file:\n- `glass/tests/unit/queries.glass` - Intent: verify database operations; Contract: guarantees isolation, rollback on error, SQL injection protection\n\nGlass spec:\n- `glass/tests/suite.glass` - Intent: comprehensive quality assurance; Contract: guarantees 80%+ coverage, all critical paths tested, no flaky tests",
        "testStrategy": "Run `npm test` and verify all tests pass. Generate coverage report with `npm run test:coverage`. Run E2E tests with `npx playwright test`. Verify tests run in CI. Test that mocked external APIs don't make real requests. Measure test execution time.",
        "priority": "high",
        "dependencies": [
          "1",
          "2",
          "3",
          "4",
          "5",
          "6",
          "7",
          "8",
          "9",
          "10",
          "11",
          "12",
          "13"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Set up Vitest configuration and test infrastructure",
            "description": "Install Vitest and configure testing environment with TypeScript support, coverage reporting, and Cloudflare Workers types for proper type checking in tests.",
            "dependencies": [],
            "details": "Install `vitest`, `@vitest/ui`, `@cloudflare/workers-types`, and `@vitest/coverage-v8`. Create `vitest.config.ts` with proper TypeScript configuration, coverage thresholds (80%+), and test environment settings. Configure test scripts in package.json: `test`, `test:watch`, `test:coverage`. Set up path aliases to match src/ structure. Configure coverage exclusions for config files and Glass specs.",
            "status": "pending",
            "testStrategy": "Run `npm test` with no tests to verify configuration loads. Check that coverage reporter initializes. Verify TypeScript types resolve correctly in test files.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Create test directory structure mirroring src/",
            "description": "Establish organized test file structure that mirrors the source code layout for maintainability and discoverability.",
            "dependencies": [
              1
            ],
            "details": "Create `tests/unit/` directory with subdirectories: `db/`, `services/`, `lib/`, `routes/api/`. Create `tests/integration/` for integration tests. Create `tests/e2e/` for Playwright tests. Set up test helper files: `tests/helpers/mocks.ts` for shared mock factories, `tests/helpers/fixtures.ts` for test data, `tests/helpers/setup.ts` for global test setup.",
            "status": "pending",
            "testStrategy": "Verify directory structure exists and matches src/ layout. Check that test files can import from helpers without path issues.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Write unit tests for db/queries.ts with mocked D1",
            "description": "Test all database CRUD operations with comprehensive mocking of Cloudflare D1 to ensure SQL queries work correctly and handle errors properly.",
            "dependencies": [
              2
            ],
            "details": "Create `tests/unit/db/queries.test.ts`. Mock D1Database interface using Vitest mocks. Test all functions: createUser, getUserById, createEntry, getEntries, updateEntry, deleteEntry, createReminder, etc. Test cases: successful operations, constraint violations (duplicate user), not found errors, SQL injection attempts (verify parameterized queries), transaction rollbacks on error. Mock D1PreparedStatement and D1Result interfaces. Verify all queries use prepared statements with bind parameters.",
            "status": "pending",
            "testStrategy": "Achieve 100% coverage of queries.ts. Verify mock D1 calls receive correct SQL and parameters. Test that no raw string concatenation occurs in SQL queries. Verify error handling paths are covered.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Write unit tests for services/ai.ts with mocked Anthropic API",
            "description": "Test AI polish functionality with mocked Claude API calls to verify prompt construction, response parsing, and error handling without making real API requests.",
            "dependencies": [
              2
            ],
            "details": "Create `tests/unit/services/ai.test.ts`. Mock Anthropic SDK client using Vitest. Test polishEntry function with various inputs: short entries, long entries, entries with markdown, entries with special characters. Mock API responses with different polished outputs. Test error scenarios: API timeout, rate limit (429), invalid API key (401), malformed response. Verify prompt includes user's voice preferences when provided. Test retry logic for transient failures. Verify no actual API calls are made by asserting mock call counts.",
            "status": "pending",
            "testStrategy": "Run tests and verify no network requests occur (can use network monitoring). Check that all voice preference combinations are tested. Verify error handling returns appropriate fallbacks. Measure test execution speed (<100ms per test).",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Write unit tests for services/transcription.ts with mocked Deepgram",
            "description": "Test transcription service with mocked Deepgram API to verify audio/video processing, response parsing, and error handling.",
            "dependencies": [
              2
            ],
            "details": "Create `tests/unit/services/transcription.test.ts`. Mock Deepgram SDK and R2 bucket operations. Test transcribeMedia function with: audio files (various formats), video files (verify audio extraction logic), very long files (streaming), multi-speaker audio (diarization). Mock Deepgram responses with realistic transcript structures including paragraphs and punctuation. Test error scenarios: unsupported format, API failure, corrupted file, timeout. Verify R2 streaming for large files. Test cost tracking metadata is populated correctly.",
            "status": "pending",
            "testStrategy": "Verify all media types are handled. Check that Deepgram API receives correct configuration (punctuation=true, paragraphs=true, diarize=true). Test error handling for each failure mode. Confirm no real R2 or API calls occur.",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Write unit tests for services/media.ts with mocked R2",
            "description": "Test media upload and download functionality with mocked Cloudflare R2 to verify file handling, validation, and error cases.",
            "dependencies": [
              2
            ],
            "details": "Create `tests/unit/services/media.test.ts`. Mock R2Bucket interface. Test uploadMedia function: valid audio files (mp3, m4a, wav), valid video files (mp4, mov), file size validation (reject >100MB), MIME type validation, generate unique keys, metadata storage. Test downloadMedia function: existing files, non-existent files (404), streaming large files. Test deleteMedia function. Verify presigned URL generation for downloads. Test error handling: R2 unavailable, insufficient storage, corrupted uploads.",
            "status": "pending",
            "testStrategy": "Achieve 100% coverage of media.ts. Verify file size and MIME type validation catches invalid inputs. Test that R2 mock receives correct bucket operations. Verify presigned URLs have correct expiration and permissions.",
            "parentId": "undefined"
          },
          {
            "id": 7,
            "title": "Write unit tests for services/sms.ts with mocked Twilio",
            "description": "Test SMS sending functionality with mocked Twilio API to verify message formatting, phone validation, and delivery handling.",
            "dependencies": [
              2
            ],
            "details": "Create `tests/unit/services/sms.test.ts`. Mock Twilio SDK client. Test sendSMS function: valid phone numbers (E.164 format), various message lengths, special characters in messages, international numbers. Test sendVerificationCode function: generates 6-digit codes, stores in KV with TTL, rate limiting (max 3 attempts per hour). Test verifyCode function: correct code, incorrect code, expired code. Mock Twilio responses: success, invalid phone number, delivery failure. Verify no actual SMS sent during tests.",
            "status": "pending",
            "testStrategy": "Run tests and confirm no real Twilio API calls occur. Verify phone number validation rejects invalid formats. Test rate limiting prevents abuse. Check that verification codes expire after configured TTL.",
            "parentId": "undefined"
          },
          {
            "id": 8,
            "title": "Write unit tests for lib/auth.ts (JWT signing/verification)",
            "description": "Test authentication utilities including JWT token generation, validation, refresh logic, and Google OAuth integration.",
            "dependencies": [
              2
            ],
            "details": "Create `tests/unit/lib/auth.test.ts`. Test signJWT function: generates valid tokens, includes correct claims (userId, email, exp), uses proper algorithm (RS256 or HS256). Test verifyJWT function: validates signature, checks expiration, rejects tampered tokens, rejects expired tokens. Test refreshToken function. Test extractUser middleware: parses Authorization header, attaches user to request context, rejects missing/invalid tokens. Mock Google OAuth verification. Test role-based access control if implemented.",
            "status": "pending",
            "testStrategy": "Test token validation with various scenarios: valid token, expired token, invalid signature, missing claims. Verify tokens can't be tampered with. Test that token expiration is enforced. Check refresh token rotation works correctly.",
            "parentId": "undefined"
          },
          {
            "id": 9,
            "title": "Write unit tests for all route handlers with mocked dependencies",
            "description": "Test all API endpoint handlers with mocked services and database to verify request/response handling, validation, and error responses.",
            "dependencies": [
              2,
              3,
              4,
              5,
              6,
              7,
              8
            ],
            "details": "Create test files: `tests/unit/routes/api/auth.test.ts`, `entries.test.ts`, `media.test.ts`, `reminders.test.ts`, `settings.test.ts`, `webhooks.test.ts`, `export.test.ts`. Mock all service layer functions and database queries. Test each endpoint: successful requests, validation errors (invalid input), authentication errors (missing/invalid token), authorization errors (accessing other user's data), rate limiting, request body parsing, response formatting. Verify HTTP status codes are correct. Test query parameter parsing and pagination.",
            "status": "pending",
            "testStrategy": "Achieve 90%+ coverage of all route handlers. Verify each endpoint returns correct status codes and response shapes. Test that authentication middleware blocks unauthenticated requests. Verify validation rejects malformed input.",
            "parentId": "undefined"
          },
          {
            "id": 10,
            "title": "Set up integration tests with real D1/R2/KV bindings",
            "description": "Configure integration test environment that uses actual Cloudflare bindings (D1, R2, KV) in local or development mode for realistic testing.",
            "dependencies": [
              1
            ],
            "details": "Create `tests/integration/setup.ts` with Wrangler integration. Use `wrangler dev --local` or leverage Miniflare for local bindings. Create test database migrations that run before integration tests. Set up test R2 bucket and KV namespace. Create `afterEach` hooks to clean up test data (truncate tables, delete R2 objects, clear KV). Configure separate test environment variables. Create helper functions to seed test data and reset state between tests.",
            "status": "pending",
            "testStrategy": "Verify integration tests can connect to local D1, R2, and KV. Test that data persists across operations within a test. Confirm cleanup hooks successfully reset state. Run integration tests in CI with local Wrangler.",
            "parentId": "undefined"
          },
          {
            "id": 11,
            "title": "Write integration test for login  create entry  list entries flow",
            "description": "Test complete user journey from authentication through creating and retrieving journal entries using real bindings.",
            "dependencies": [
              10
            ],
            "details": "Create `tests/integration/flows/journaling.test.ts`. Test flow: (1) POST /api/auth/google with mock OAuth token  receive JWT, (2) POST /api/entries with JWT  create entry, verify stored in D1, (3) GET /api/entries with JWT  verify entry returned, (4) POST /api/entries with media attachment  verify R2 upload, (5) trigger AI polish  verify processing_log entry, (6) verify transcription for media entry. Use real D1 database, R2 storage, KV for sessions. Mock only external APIs (Google, Anthropic, Deepgram, Twilio).",
            "status": "pending",
            "testStrategy": "Run end-to-end flow and verify each step succeeds. Check that data persists correctly in D1. Verify R2 objects are created and retrievable. Confirm JWT authentication works across requests. Measure total flow execution time.",
            "parentId": "undefined"
          },
          {
            "id": 12,
            "title": "Write integration test for webhook processing with mocked Twilio",
            "description": "Test SMS webhook handling including signature validation, entry creation, and media processing with realistic Twilio payloads.",
            "dependencies": [
              10
            ],
            "details": "Create `tests/integration/webhooks.test.ts`. Test POST /api/webhooks/sms with: valid Twilio signature (use Twilio's signature algorithm), text-only message  creates entry, message with media URL  downloads and processes media, invalid signature  rejected (403), duplicate message handling, rate limiting per phone number. Mock Twilio signature generation for test requests. Use real D1 for entry storage, real R2 for media. Mock external media downloads and transcription API. Test webhook idempotency.",
            "status": "pending",
            "testStrategy": "Verify signature validation rejects tampered requests. Test that valid webhooks create entries in database. Confirm media is downloaded and stored in R2. Test rate limiting blocks spam. Verify idempotency prevents duplicate entries.",
            "parentId": "undefined"
          },
          {
            "id": 13,
            "title": "Write integration test for cron trigger logic",
            "description": "Test scheduled reminder functionality including trigger evaluation, SMS sending, and reminder status updates.",
            "dependencies": [
              10
            ],
            "details": "Create `tests/integration/cron.test.ts`. Test cron handler: (1) seed database with reminders at various times and frequencies (daily, weekly), (2) mock current time to match reminder trigger time, (3) invoke cron handler, (4) verify correct reminders are triggered, (5) verify SMS sent to verified phone numbers, (6) verify last_sent timestamp updated, (7) test timezone handling (reminders fire at correct local time). Mock Twilio SMS API. Use real D1 for reminder queries. Test edge cases: user with no phone number, unverified phone, disabled reminders, overlapping schedules.",
            "status": "pending",
            "testStrategy": "Test with various times and frequencies. Verify only due reminders trigger. Check timezone conversion is correct. Confirm SMS sent to verified numbers only. Verify last_sent updates prevent duplicate triggers.",
            "parentId": "undefined"
          },
          {
            "id": 14,
            "title": "Set up Playwright for E2E tests covering critical user flows",
            "description": "Configure Playwright testing framework and implement end-to-end tests for critical user journeys including sign-up, phone verification, entry creation, and data export.",
            "dependencies": [
              1
            ],
            "details": "Install `@playwright/test`. Create `playwright.config.ts` with browser configurations (chromium, firefox, webkit), base URL for local dev server, video recording on failure, screenshot on failure. Create `tests/e2e/` directory. Implement page object models for: Login page, Dashboard, Entry creation, Settings. Write E2E tests: (1) Sign up with Google OAuth (mock OAuth flow), (2) Verify phone number (mock SMS code), (3) Create entry via web form  verify appears in list, (4) Simulate SMS entry via webhook  verify in dashboard, (5) Configure reminder in settings  verify saved, (6) Export data  verify JSON download. Set up test user accounts and cleanup.",
            "status": "pending",
            "testStrategy": "Run Playwright tests in headless mode. Verify tests pass in all browsers. Check that OAuth mock flow works correctly. Test on different viewport sizes (mobile, desktop). Measure E2E test execution time. Verify tests run in CI with video artifacts on failure.",
            "parentId": "undefined"
          },
          {
            "id": 15,
            "title": "Configure coverage reporting with 80%+ target",
            "description": "Set up comprehensive code coverage reporting to track test coverage across unit and integration tests and ensure quality standards are met.",
            "dependencies": [
              1,
              3,
              4,
              5,
              6,
              7,
              8,
              9,
              11,
              12,
              13
            ],
            "details": "Configure `@vitest/coverage-v8` in vitest.config.ts with coverage thresholds: statements 80%, branches 80%, functions 80%, lines 80%. Exclude from coverage: Glass specs, test files, config files, type definitions. Generate coverage reports in multiple formats: HTML (for local viewing), JSON (for CI), lcov (for integration with coverage tools). Configure coverage to fail CI if below thresholds. Create npm script `test:coverage` that runs all tests and generates report. Set up coverage badges for README. Identify uncovered code paths and add tests to reach 80%+ target.",
            "status": "pending",
            "testStrategy": "Run `npm run test:coverage` and verify report generates. Check that coverage meets 80%+ threshold across all metrics. Review HTML report to identify gaps. Verify CI fails when coverage drops below threshold. Test that excluded files don't count toward coverage.",
            "parentId": "undefined"
          },
          {
            "id": 16,
            "title": "Create Glass specs for test files with isolation contracts",
            "description": "Document testing contracts and guarantees using Glass Framework specifications to ensure test quality, isolation, and reliability.",
            "dependencies": [
              14,
              15
            ],
            "details": "Create `glass/tests/unit/queries.glass` with: Intent: verify database operations in isolation; Contract: guarantees test isolation (no shared state), automatic rollback on error, SQL injection protection verification, 100% coverage of CRUD operations. Create `glass/tests/integration/flows.glass` with isolation contracts for integration tests. Create `glass/tests/e2e/playwright.glass` documenting E2E test guarantees. Create master spec `glass/tests/suite.glass` with: Intent: comprehensive quality assurance; Contract: guarantees 80%+ coverage, all critical user paths tested, no flaky tests (max 1% flake rate), tests run in <5 minutes, parallel execution safe, deterministic results. Document mocking strategy and test data management in Glass specs.",
            "status": "pending",
            "testStrategy": "Verify Glass specs exist for all test categories. Check that contracts document isolation guarantees. Review specs with team to ensure clarity. Verify test suite meets all documented contracts (coverage, speed, reliability). Run tests 10 times to measure flake rate.",
            "parentId": "undefined"
          }
        ],
        "complexity": 9,
        "recommendedSubtasks": 16,
        "expansionPrompt": "Break down test suite into: (1) set up Vitest configuration, (2) create test structure mirroring src/, (3) write unit tests for db/queries.ts with mocked D1, (4) write unit tests for services/ai.ts with mocked Anthropic API, (5) write unit tests for services/transcription.ts with mocked Deepgram, (6) write unit tests for services/media.ts with mocked R2, (7) write unit tests for services/sms.ts with mocked Twilio, (8) write unit tests for lib/auth.ts (JWT signing/verification), (9) write unit tests for all route handlers with mocked dependencies, (10) set up integration tests with real D1/R2/KV bindings, (11) write integration test for login  create entry  list entries flow, (12) write integration test for webhook processing with mocked Twilio, (13) write integration test for cron trigger logic, (14) set up Playwright for E2E tests (sign up, verify phone, create entry, configure reminder, export), (15) configure coverage reporting (target 80%+), (16) create Glass specs for test files with isolation contracts"
      },
      {
        "id": "23",
        "title": "Initialize GitHub repository and configure version control",
        "description": "Create the GitHub repository 'supercleanse/journalizer', initialize local git repository, configure remote origin, commit all existing project files (CLAUDE.md, GLASS.md, manifest.glass, glass.config.json, .gitignore, docs/PRD.md, .taskmaster config), and push to remote.",
        "status": "in-progress",
        "dependencies": [],
        "priority": "high",
        "details": "**CRITICAL: This is the very first task in the entire project.** This foundational task establishes version control and the remote repository infrastructure that all subsequent development depends on. No other development work can begin until this task is completed.\n\n**Current project state:**\n- Project directory exists at `/Users/supercleanse/Development/journalizer`\n- Git repository has NOT been initialized yet (no .git directory)\n- Project files exist locally: CLAUDE.md, GLASS.md, manifest.glass, glass.config.json, .gitignore, .mcp.json, docs/PRD.md, .taskmaster/config.json, and directory structures (annotations/, glass/, glass-views/, src/, tests/, dist/)\n- No remote repository exists yet\n\n**Prerequisites:**\n- GitHub account 'supercleanse' must exist\n- GitHub CLI (`gh`) or GitHub API access credentials available\n- Git installed locally\n\n**Step-by-step implementation:**\n\n1. **Create GitHub repository:**\n   ```bash\n   gh repo create supercleanse/journalizer --public --description \"AI-powered personal journal with SMS/web entry, voice transcription, and smart reminders\" --source=. --remote=origin\n   ```\n   Alternative using GitHub API if `gh` is not available:\n   ```bash\n   curl -X POST https://api.github.com/user/repos \\\n     -H \"Authorization: token $GITHUB_TOKEN\" \\\n     -d '{\"name\":\"journalizer\",\"description\":\"AI-powered personal journal\",\"private\":false}'\n   ```\n\n2. **Initialize local git repository:**\n   ```bash\n   cd /Users/supercleanse/Development/journalizer\n   git init\n   ```\n\n3. **Update .gitignore with project-specific entries:**\n   The existing .gitignore currently contains only:\n   ```\n   node_modules/\n   dist/\n   *.log\n   .DS_Store\n   ```\n   \n   Must add additional entries for this project:\n   ```\n   .env\n   .env.local\n   .wrangler/\n   .claude/settings.local.json\n   .taskmaster/state.json\n   ```\n   \n   These additions prevent sensitive and local-specific files from being committed.\n\n4. **Stage all project files:**\n   ```bash\n   git add .gitignore\n   git add CLAUDE.md GLASS.md manifest.glass glass.config.json\n   git add docs/PRD.md\n   git add .taskmaster/config.json\n   git add .mcp.json\n   git add annotations/ glass/ glass-views/ src/ tests/ dist/\n   ```\n\n5. **Create initial commit:**\n   ```bash\n   git commit -m \"Initial commit: Project setup with Glass Framework\n\n- Add Glass Framework documentation (GLASS.md, CLAUDE.md)\n- Add project manifest and configuration (manifest.glass, glass.config.json)\n- Add PRD documentation (docs/PRD.md)\n- Add TaskMaster AI configuration (.taskmaster/config.json)\n- Add MCP server configuration (.mcp.json)\n- Configure gitignore for Node.js and Glass projects\n- Initialize project structure (glass/, src/, tests/, annotations/, glass-views/)\n\n Generated with [Claude Code](https://claude.com/claude-code)\n\nCo-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>\"\n   ```\n\n6. **Configure remote origin:**\n   If not already configured by `gh repo create`:\n   ```bash\n   git remote add origin https://github.com/supercleanse/journalizer.git\n   ```\n\n7. **Verify remote configuration:**\n   ```bash\n   git remote -v\n   ```\n\n8. **Push to remote repository:**\n   ```bash\n   git branch -M main\n   git push -u origin main\n   ```\n\n9. **Configure branch protection rules (recommended):**\n   ```bash\n   gh repo edit supercleanse/journalizer --enable-auto-merge --delete-branch-on-merge\n   ```\n\n**Important considerations:**\n- According to CLAUDE.md, this project follows a feature branch workflow with PR-based development\n- Main branch should be protected to enforce the PR workflow\n- All future development (starting with Task 1) must follow: feature branch  PR  reviews  merge\n- The .taskmaster/state.json file contains transient state and should be added to .gitignore\n- The .claude/settings.local.json is user-specific and should remain in .gitignore\n\n**Files to commit (verified to exist):**\n- CLAUDE.md (669 bytes) - Feature development process documentation\n- GLASS.md (4420 bytes) - Glass Framework methodology\n- manifest.glass (307 bytes) - Living requirements document\n- glass.config.json (221 bytes) - Project configuration\n- .gitignore (36 bytes) - Git exclusion rules (will be updated)\n- docs/PRD.md - Product requirements document\n- .taskmaster/config.json - TaskMaster configuration\n- .mcp.json (187 bytes) - MCP server configuration\n- Directory structures: annotations/, glass/, glass-views/, src/, tests/, dist/\n\n**Blocking relationship:**\nThis task blocks Task 1 (Initialize Cloudflare Workers project) and ALL other tasks because:\n- Version control must be established before any code is written\n- Task 1's Cloudflare Workers initialization will generate files (package.json, wrangler.toml, etc.) that need to be tracked in git\n- The feature branch workflow required by CLAUDE.md needs a main branch to exist\n- CI/CD pipelines (required by Task 1+) integrate with the GitHub repository\n- **This is explicitly the first task that must be completed before any development begins**",
        "testStrategy": "**Verification steps:**\n\n1. **Verify GitHub repository exists:**\n   ```bash\n   gh repo view supercleanse/journalizer\n   ```\n   Should display repository details including description and URL.\n\n2. **Verify local git initialization:**\n   ```bash\n   git status\n   ```\n   Should show \"On branch main\" and no errors.\n\n3. **Verify remote configuration:**\n   ```bash\n   git remote get-url origin\n   ```\n   Should output: `https://github.com/supercleanse/journalizer.git`\n\n4. **Verify all files are committed:**\n   ```bash\n   git log --oneline\n   git ls-tree -r main --name-only\n   ```\n   Should show initial commit and list all committed files including:\n   - CLAUDE.md\n   - GLASS.md\n   - manifest.glass\n   - glass.config.json\n   - .gitignore\n   - docs/PRD.md\n   - .taskmaster/config.json\n   - .mcp.json\n\n5. **Verify push to remote:**\n   ```bash\n   git log origin/main\n   ```\n   Should show the same commit as local main branch.\n   \n   Visit https://github.com/supercleanse/journalizer in browser and verify:\n   - Repository is visible\n   - Initial commit appears in commit history\n   - All files are visible in the repository\n   - Project description is displayed\n\n6. **Verify .gitignore is working:**\n   ```bash\n   git status --ignored\n   ```\n   Should show .taskmaster/state.json, .claude/settings.local.json in ignored files section.\n\n7. **Verify branch setup:**\n   ```bash\n   git branch -vv\n   ```\n   Should show main branch tracking origin/main with [origin/main] indicator.\n\n8. **Test feature branch workflow (required for subsequent tasks):**\n   ```bash\n   git checkout -b test/verify-git-setup\n   echo \"# Journalizer\" > README.md\n   git add README.md\n   git commit -m \"test: verify git workflow\"\n   git push -u origin test/verify-git-setup\n   ```\n   Should successfully push feature branch. Then verify branch appears on GitHub and delete:\n   ```bash\n   git checkout main\n   git branch -D test/verify-git-setup\n   git push origin --delete test/verify-git-setup\n   ```\n\n9. **Verify no sensitive files committed:**\n   ```bash\n   git log --all --full-history -- \".env*\" \"*.key\" \"*.pem\" \".taskmaster/state.json\" \".claude/settings.local.json\"\n   ```\n   Should return empty (no matches).\n\n10. **Verify repository is ready for Task 1:**\n   ```bash\n   git status\n   ```\n   Should show clean working tree on main branch, ready for feature branch creation.\n\n**Success criteria:**\n-  GitHub repository supercleanse/journalizer exists and is accessible\n-  Local repository initialized with main branch\n-  Remote origin points to github.com/supercleanse/journalizer\n-  Initial commit contains all documented files\n-  Commit is pushed and visible on GitHub\n-  .gitignore properly excludes generated, local, and sensitive files\n-  Feature branch workflow is functional (tested)\n-  Repository is ready for Task 1 to begin",
        "subtasks": [],
        "updatedAt": "2026-02-02T23:54:34.160Z"
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2026-02-02T23:54:34.161Z",
      "taskCount": 23,
      "completedCount": 0,
      "tags": [
        "master"
      ]
    }
  }
}